# ç¬¬2ç« ï¼šç¶²ç«™æŒ‡ç´‹åˆ†æå¼•æ“ (Website Fingerprint Engine)

## 2.12 å¯¦æˆ°ç¯„ä¾‹é›†

**[â† è¿”å›ç¬¬2ç« é¦–é ](ch2-index.md)**

---

æœ¬ç« ç¯€æä¾›ç¶²ç«™æŒ‡ç´‹åˆ†æå¼•æ“çš„å¯¦éš›æ‡‰ç”¨ç¯„ä¾‹ã€‚

## ğŸ¯ ç¯„ä¾‹ç´¢å¼•

| ç¯„ä¾‹ç·¨è™Ÿ | åç¨± | é›£åº¦ | å ´æ™¯ |
|---------|------|------|------|
| 1 | åŸºç¤æŒ‡ç´‹è­˜åˆ¥ | â­â­ | ç¶²ç«™é¡å‹è­˜åˆ¥ |
| 2 | è‡ªå®šç¾©æŒ‡ç´‹è¦å‰‡ | â­â­â­ | è¦å‰‡é–‹ç™¼ |
| 3 | æ‰¹é‡ç¶²ç«™åˆ†æ | â­â­â­ | å¤§è¦æ¨¡æƒæ |
| 4 | å‹•æ…‹ç¶²ç«™æŒ‡ç´‹ | â­â­â­â­ | JSæ¸²æŸ“åˆ†æ |
| 5 | æŒ‡ç´‹ç›¸ä¼¼åº¦è¨ˆç®— | â­â­â­â­ | ç›¸ä¼¼æ€§åˆ†æ |
| 6 | æ™ºèƒ½æŒ‡ç´‹å­¸ç¿’ | â­â­â­â­â­ | æ©Ÿå™¨å­¸ç¿’ |

---

## ç¯„ä¾‹ 1: åŸºç¤æŒ‡ç´‹è­˜åˆ¥ç³»çµ±

### å ´æ™¯æè¿°
å¯¦ç¾ä¸€å€‹å®Œæ•´çš„ç¶²ç«™æŒ‡ç´‹è­˜åˆ¥ç³»çµ±ï¼Œèƒ½å¤ è­˜åˆ¥å¸¸è¦‹çš„ CMS å’Œæ¡†æ¶ã€‚

### å®Œæ•´å¯¦ç¾

```python
import requests
from bs4 import BeautifulSoup
from typing import Dict, List, Optional
import re
from dataclasses import dataclass
from enum import Enum

class WebsiteType(Enum):
    """ç¶²ç«™é¡å‹"""
    WORDPRESS = "WordPress"
    DRUPAL = "Drupal"
    JOOMLA = "Joomla"
    SHOPIFY = "Shopify"
    WOOCOMMERCE = "WooCommerce"
    MAGENTO = "Magento"
    DJANGO = "Django"
    LARAVEL = "Laravel"
    REACT = "React"
    VUE = "Vue.js"
    ANGULAR = "Angular"
    UNKNOWN = "Unknown"

@dataclass
class FingerprintMatch:
    """æŒ‡ç´‹åŒ¹é…çµæœ"""
    website_type: WebsiteType
    confidence: float
    matched_features: List[str]
    evidence: Dict[str, any]

class BasicFingerprintDetector:
    """åŸºç¤æŒ‡ç´‹æª¢æ¸¬å™¨"""
    
    def __init__(self):
        self.rules = self._load_rules()
    
    def _load_rules(self) -> Dict:
        """è¼‰å…¥æŒ‡ç´‹è¦å‰‡"""
        return {
            WebsiteType.WORDPRESS: {
                'meta_tags': ['generator=WordPress'],
                'paths': ['/wp-content/', '/wp-includes/', '/wp-admin/'],
                'headers': {},
                'scripts': ['wp-embed.min.js', 'wp-emoji-release.min.js'],
                'cookies': ['wordpress_', 'wp-settings']
            },
            WebsiteType.DRUPAL: {
                'meta_tags': ['generator=Drupal'],
                'paths': ['/sites/default/', '/modules/', '/themes/'],
                'headers': {'X-Drupal-Cache': '*'},
                'scripts': ['drupal.js'],
                'cookies': ['SESS']
            },
            WebsiteType.SHOPIFY: {
                'meta_tags': [],
                'paths': ['/cdn.shopify.com/'],
                'headers': {'X-ShopId': '*'},
                'scripts': ['shopify'],
                'cookies': ['_shopify_']
            },
            WebsiteType.REACT: {
                'meta_tags': [],
                'paths': [],
                'headers': {},
                'scripts': ['react', 'react-dom'],
                'dom_attributes': ['data-reactroot', 'data-reactid']
            },
            WebsiteType.VUE: {
                'meta_tags': [],
                'paths': [],
                'headers': {},
                'scripts': ['vue.js', 'vue.min.js'],
                'dom_attributes': ['data-v-', 'v-cloak']
            }
        }
    
    def detect(self, url: str) -> FingerprintMatch:
        """æª¢æ¸¬ç¶²ç«™æŒ‡ç´‹"""
        try:
            # ç²å–ç¶²é å…§å®¹
            response = requests.get(url, timeout=10, headers={
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            })
            
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # æå–ç‰¹å¾µ
            features = {
                'html': response.text,
                'headers': dict(response.headers),
                'cookies': response.cookies,
                'soup': soup
            }
            
            # å˜—è©¦åŒ¹é…æ¯å€‹è¦å‰‡
            matches = []
            for website_type, rules in self.rules.items():
                match_result = self._match_rules(features, rules, website_type)
                if match_result.confidence > 0:
                    matches.append(match_result)
            
            # è¿”å›æœ€ä½³åŒ¹é…
            if matches:
                matches.sort(key=lambda x: x.confidence, reverse=True)
                return matches[0]
            
            return FingerprintMatch(
                website_type=WebsiteType.UNKNOWN,
                confidence=0.0,
                matched_features=[],
                evidence={}
            )
            
        except Exception as e:
            raise Exception(f"æª¢æ¸¬å¤±æ•—: {str(e)}")
    
    def _match_rules(self, features: Dict, rules: Dict, website_type: WebsiteType) -> FingerprintMatch:
        """åŒ¹é…è¦å‰‡"""
        matched_features = []
        evidence = {}
        score = 0.0
        max_score = 0.0
        
        # æª¢æŸ¥ meta æ¨™ç±¤
        if 'meta_tags' in rules:
            max_score += 0.3
            for tag_pattern in rules['meta_tags']:
                meta = features['soup'].find('meta', attrs={'name': 'generator'})
                if meta and tag_pattern.split('=')[1] in meta.get('content', ''):
                    matched_features.append(f"meta: {tag_pattern}")
                    evidence['meta'] = meta.get('content')
                    score += 0.3
                    break
        
        # æª¢æŸ¥è·¯å¾‘
        if 'paths' in rules:
            max_score += 0.3
            html = features['html']
            for path in rules['paths']:
                if path in html:
                    matched_features.append(f"path: {path}")
                    evidence.setdefault('paths', []).append(path)
                    score += 0.3 / len(rules['paths'])
        
        # æª¢æŸ¥è…³æœ¬
        if 'scripts' in rules:
            max_score += 0.2
            scripts = features['soup'].find_all('script', src=True)
            for script in scripts:
                src = script.get('src', '')
                for script_pattern in rules['scripts']:
                    if script_pattern in src:
                        matched_features.append(f"script: {script_pattern}")
                        evidence.setdefault('scripts', []).append(src)
                        score += 0.2 / len(rules['scripts'])
                        break
        
        # æª¢æŸ¥ headers
        if 'headers' in rules:
            max_score += 0.1
            for header_key, header_value in rules['headers'].items():
                if header_key in features['headers']:
                    matched_features.append(f"header: {header_key}")
                    evidence['headers'] = {header_key: features['headers'][header_key]}
                    score += 0.1
        
        # æª¢æŸ¥ DOM å±¬æ€§
        if 'dom_attributes' in rules:
            max_score += 0.1
            html = features['html']
            for attr in rules['dom_attributes']:
                if attr in html:
                    matched_features.append(f"dom: {attr}")
                    evidence.setdefault('dom_attributes', []).append(attr)
                    score += 0.1 / len(rules['dom_attributes'])
        
        confidence = score / max_score if max_score > 0 else 0.0
        
        return FingerprintMatch(
            website_type=website_type,
            confidence=confidence,
            matched_features=matched_features,
            evidence=evidence
        )
    
    def batch_detect(self, urls: List[str]) -> List[Dict]:
        """æ‰¹é‡æª¢æ¸¬"""
        results = []
        
        for url in urls:
            try:
                match = self.detect(url)
                results.append({
                    'url': url,
                    'type': match.website_type.value,
                    'confidence': match.confidence,
                    'features': match.matched_features,
                    'success': True
                })
            except Exception as e:
                results.append({
                    'url': url,
                    'error': str(e),
                    'success': False
                })
        
        return results

# ä½¿ç”¨ç¯„ä¾‹
detector = BasicFingerprintDetector()

# æª¢æ¸¬å–®å€‹ç¶²ç«™
match = detector.detect("https://wordpress-site.com")
print(f"ç¶²ç«™é¡å‹: {match.website_type.value}")
print(f"ç½®ä¿¡åº¦: {match.confidence:.2%}")
print(f"åŒ¹é…ç‰¹å¾µ: {match.matched_features}")

# æ‰¹é‡æª¢æ¸¬
urls = [
    "https://site1.com",
    "https://site2.com",
    "https://site3.com"
]
results = detector.batch_detect(urls)

# ç”Ÿæˆå ±å‘Š
import pandas as pd
df = pd.DataFrame(results)
df.to_excel("fingerprint_results.xlsx", index=False)
```

---

## ç¯„ä¾‹ 2: å‹•æ…‹ç¶²ç«™æŒ‡ç´‹åˆ†æ

### å ´æ™¯æè¿°
è™•ç†éœ€è¦ JavaScript æ¸²æŸ“çš„ç¾ä»£ SPA (Single Page Application) ç¶²ç«™ã€‚

### å®Œæ•´å¯¦ç¾

```python
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time
import json

class DynamicFingerprintAnalyzer:
    """å‹•æ…‹ç¶²ç«™æŒ‡ç´‹åˆ†æå™¨"""
    
    def __init__(self, headless=True):
        self.headless = headless
        self.driver = None
    
    def _init_driver(self):
        """åˆå§‹åŒ–ç€è¦½å™¨"""
        options = Options()
        if self.headless:
            options.add_argument('--headless')
        options.add_argument('--disable-gpu')
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        
        # ç¦ç”¨åœ–ç‰‡è¼‰å…¥ä»¥åŠ é€Ÿ
        prefs = {
            'profile.managed_default_content_settings.images': 2,
            'profile.default_content_setting_values.notifications': 2
        }
        options.add_experimental_option('prefs', prefs)
        
        self.driver = webdriver.Chrome(options=options)
        self.driver.set_page_load_timeout(30)
    
    def analyze(self, url: str) -> Dict:
        """åˆ†æå‹•æ…‹ç¶²ç«™"""
        if not self.driver:
            self._init_driver()
        
        try:
            # è¼‰å…¥é é¢
            self.driver.get(url)
            
            # ç­‰å¾… JavaScript åŸ·è¡Œ
            time.sleep(3)
            
            # æå–ç‰¹å¾µ
            features = {
                'framework': self._detect_framework(),
                'libraries': self._detect_libraries(),
                'api_calls': self._capture_api_calls(),
                'websockets': self._detect_websockets(),
                'spa_indicators': self._detect_spa_indicators(),
                'dom_structure': self._analyze_dom_structure(),
                'performance': self._get_performance_metrics()
            }
            
            return features
            
        except Exception as e:
            raise Exception(f"åˆ†æå¤±æ•—: {str(e)}")
    
    def _detect_framework(self) -> Dict:
        """æª¢æ¸¬å‰ç«¯æ¡†æ¶"""
        frameworks = {}
        
        # æª¢æ¸¬ React
        react_check = self.driver.execute_script("""
            return {
                hasReact: typeof React !== 'undefined',
                hasReactDOM: typeof ReactDOM !== 'undefined',
                version: typeof React !== 'undefined' ? React.version : null,
                devTools: window.__REACT_DEVTOOLS_GLOBAL_HOOK__ !== undefined
            };
        """)
        if react_check['hasReact']:
            frameworks['React'] = react_check
        
        # æª¢æ¸¬ Vue
        vue_check = self.driver.execute_script("""
            return {
                hasVue: typeof Vue !== 'undefined',
                version: typeof Vue !== 'undefined' ? Vue.version : null,
                devTools: window.__VUE_DEVTOOLS_GLOBAL_HOOK__ !== undefined,
                apps: document.querySelectorAll('[data-v-app]').length
            };
        """)
        if vue_check['hasVue']:
            frameworks['Vue'] = vue_check
        
        # æª¢æ¸¬ Angular
        angular_check = self.driver.execute_script("""
            return {
                hasAngular: typeof angular !== 'undefined' || document.querySelector('[ng-version]') !== null,
                version: document.querySelector('[ng-version]')?.getAttribute('ng-version'),
                isAngularJS: typeof angular !== 'undefined'
            };
        """)
        if angular_check['hasAngular']:
            frameworks['Angular'] = angular_check
        
        return frameworks
    
    def _detect_libraries(self) -> List[str]:
        """æª¢æ¸¬ä½¿ç”¨çš„ JavaScript åº«"""
        libraries = self.driver.execute_script("""
            const libs = [];
            
            // å¸¸è¦‹åº«æª¢æ¸¬
            if (typeof jQuery !== 'undefined') libs.push(`jQuery ${jQuery.fn.jquery}`);
            if (typeof _ !== 'undefined') libs.push('Lodash');
            if (typeof moment !== 'undefined') libs.push('Moment.js');
            if (typeof axios !== 'undefined') libs.push('Axios');
            if (typeof $ !== 'undefined' && typeof $.fn.modal !== 'undefined') libs.push('Bootstrap');
            
            return libs;
        """)
        
        return libraries
    
    def _capture_api_calls(self) -> List[Dict]:
        """æ•ç² API èª¿ç”¨"""
        # ç²å–ç¶²è·¯è«‹æ±‚æ—¥èªŒ
        logs = self.driver.get_log('performance')
        api_calls = []
        
        for log in logs:
            message = json.loads(log['message'])
            method = message.get('message', {}).get('method', '')
            
            if 'Network.responseReceived' in method:
                response = message.get('message', {}).get('params', {}).get('response', {})
                url = response.get('url', '')
                
                # éæ¿¾ API èª¿ç”¨
                if any(pattern in url for pattern in ['/api/', '/graphql', '.json', '/rest/']):
                    api_calls.append({
                        'url': url,
                        'method': response.get('method'),
                        'status': response.get('status'),
                        'mimeType': response.get('mimeType')
                    })
        
        return api_calls
    
    def _detect_websockets(self) -> Dict:
        """æª¢æ¸¬ WebSocket ä½¿ç”¨"""
        ws_info = self.driver.execute_script("""
            return {
                hasWebSocket: typeof WebSocket !== 'undefined',
                connections: performance.getEntriesByType('resource')
                    .filter(r => r.name.startsWith('ws://') || r.name.startsWith('wss://'))
                    .map(r => r.name)
            };
        """)
        
        return ws_info
    
    def _detect_spa_indicators(self) -> Dict:
        """æª¢æ¸¬ SPA ç‰¹å¾µ"""
        indicators = self.driver.execute_script("""
            return {
                hasRouter: window.location.hash.includes('#/') || history.pushState !== undefined,
                hasVirtualDOM: document.querySelector('[data-reactroot], [data-reactid], [data-v-]') !== null,
                dynamicContent: document.querySelector('[data-dynamic], [data-bind]') !== null,
                lazyLoading: document.querySelector('[loading="lazy"]') !== null
            };
        """)
        
        return indicators
    
    def _analyze_dom_structure(self) -> Dict:
        """åˆ†æ DOM çµæ§‹"""
        structure = self.driver.execute_script("""
            function getDOMDepth(element) {
                let maxDepth = 0;
                for (let child of element.children) {
                    maxDepth = Math.max(maxDepth, getDOMDepth(child));
                }
                return maxDepth + 1;
            }
            
            return {
                depth: getDOMDepth(document.body),
                elementCount: document.querySelectorAll('*').length,
                scriptTags: document.querySelectorAll('script').length,
                styleTags: document.querySelectorAll('style, link[rel="stylesheet"]').length
            };
        """)
        
        return structure
    
    def _get_performance_metrics(self) -> Dict:
        """ç²å–æ•ˆèƒ½æŒ‡æ¨™"""
        metrics = self.driver.execute_script("""
            const perfData = window.performance.timing;
            const navigation = performance.getEntriesByType('navigation')[0];
            
            return {
                loadTime: perfData.loadEventEnd - perfData.navigationStart,
                domReady: perfData.domContentLoadedEventEnd - perfData.navigationStart,
                firstPaint: navigation ? navigation.responseStart - navigation.requestStart : 0,
                resources: performance.getEntriesByType('resource').length
            };
        """)
        
        return metrics
    
    def close(self):
        """é—œé–‰ç€è¦½å™¨"""
        if self.driver:
            self.driver.quit()
            self.driver = None

# ä½¿ç”¨ç¯„ä¾‹
analyzer = DynamicFingerprintAnalyzer(headless=True)

try:
    # åˆ†æ React æ‡‰ç”¨
    features = analyzer.analyze("https://react-app.com")
    
    print("æª¢æ¸¬åˆ°çš„æ¡†æ¶:")
    for framework, details in features['framework'].items():
        print(f"  {framework}: {details}")
    
    print(f"\nä½¿ç”¨çš„åº«: {', '.join(features['libraries'])}")
    print(f"API èª¿ç”¨æ•¸: {len(features['api_calls'])}")
    print(f"DOM æ·±åº¦: {features['dom_structure']['depth']}")
    print(f"è¼‰å…¥æ™‚é–“: {features['performance']['loadTime']}ms")
    
finally:
    analyzer.close()
```

---

## ç¯„ä¾‹ 3: æŒ‡ç´‹ç›¸ä¼¼åº¦æ¯”è¼ƒç³»çµ±

### å ´æ™¯æè¿°
æ¯”è¼ƒå…©å€‹ç¶²ç«™çš„æŒ‡ç´‹ç›¸ä¼¼åº¦ï¼Œç”¨æ–¼è­˜åˆ¥é¡åƒç«™é»æˆ–ç›¸ä¼¼ç¶²ç«™ã€‚

### å®Œæ•´å¯¦ç¾

```python
from typing import Set, Dict, List
from dataclasses import dataclass
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

@dataclass
class SimilarityScore:
    """ç›¸ä¼¼åº¦å¾—åˆ†"""
    overall: float
    structural: float
    visual: float
    content: float
    behavioral: float
    details: Dict

class FingerprintSimilarityCalculator:
    """æŒ‡ç´‹ç›¸ä¼¼åº¦è¨ˆç®—å™¨"""
    
    def __init__(self):
        self.vectorizer = TfidfVectorizer()
    
    def calculate(self, fingerprint1: Dict, fingerprint2: Dict) -> SimilarityScore:
        """è¨ˆç®—å…©å€‹æŒ‡ç´‹çš„ç›¸ä¼¼åº¦"""
        
        scores = {
            'structural': self._compare_structure(fingerprint1, fingerprint2),
            'visual': self._compare_visual(fingerprint1, fingerprint2),
            'content': self._compare_content(fingerprint1, fingerprint2),
            'behavioral': self._compare_behavioral(fingerprint1, fingerprint2)
        }
        
        # åŠ æ¬Šå¹³å‡
        weights = {
            'structural': 0.3,
            'visual': 0.2,
            'content': 0.3,
            'behavioral': 0.2
        }
        
        overall = sum(scores[k] * weights[k] for k in scores)
        
        return SimilarityScore(
            overall=overall,
            structural=scores['structural'],
            visual=scores['visual'],
            content=scores['content'],
            behavioral=scores['behavioral'],
            details=self._generate_details(fingerprint1, fingerprint2, scores)
        )
    
    def _compare_structure(self, fp1: Dict, fp2: Dict) -> float:
        """æ¯”è¼ƒçµæ§‹ç›¸ä¼¼åº¦"""
        # æ¯”è¼ƒ DOM çµæ§‹
        dom1 = set(fp1.get('dom_tags', []))
        dom2 = set(fp2.get('dom_tags', []))
        
        # Jaccard ç›¸ä¼¼åº¦
        intersection = len(dom1 & dom2)
        union = len(dom1 | dom2)
        
        jaccard = intersection / union if union > 0 else 0
        
        # æ¯”è¼ƒå±¤æ¬¡çµæ§‹
        depth_diff = abs(fp1.get('dom_depth', 0) - fp2.get('dom_depth', 0))
        depth_sim = 1 / (1 + depth_diff / 10)  # æ¨™æº–åŒ–
        
        return (jaccard + depth_sim) / 2
    
    def _compare_visual(self, fp1: Dict, fp2: Dict) -> float:
        """æ¯”è¼ƒè¦–è¦ºç›¸ä¼¼åº¦"""
        # æ¯”è¼ƒé¡è‰²åˆ†å¸ƒ
        colors1 = set(fp1.get('dominant_colors', []))
        colors2 = set(fp2.get('dominant_colors', []))
        
        color_sim = len(colors1 & colors2) / max(len(colors1), len(colors2)) if colors1 or colors2 else 0
        
        # æ¯”è¼ƒå¸ƒå±€ç›¸ä¼¼åº¦
        layout1 = fp1.get('layout_structure', {})
        layout2 = fp2.get('layout_structure', {})
        
        layout_sim = self._compare_dicts(layout1, layout2)
        
        return (color_sim + layout_sim) / 2
    
    def _compare_content(self, fp1: Dict, fp2: Dict) -> float:
        """æ¯”è¼ƒå…§å®¹ç›¸ä¼¼åº¦"""
        text1 = fp1.get('text_content', '')
        text2 = fp2.get('text_content', '')
        
        if not text1 or not text2:
            return 0.0
        
        # ä½¿ç”¨ TF-IDF å’Œé¤˜å¼¦ç›¸ä¼¼åº¦
        try:
            vectors = self.vectorizer.fit_transform([text1, text2])
            similarity = cosine_similarity(vectors[0:1], vectors[1:2])[0][0]
            return similarity
        except:
            return 0.0
    
    def _compare_behavioral(self, fp1: Dict, fp2: Dict) -> float:
        """æ¯”è¼ƒè¡Œç‚ºç›¸ä¼¼åº¦"""
        # æ¯”è¼ƒ API ç«¯é»
        apis1 = set(fp1.get('api_endpoints', []))
        apis2 = set(fp2.get('api_endpoints', []))
        
        api_sim = len(apis1 & apis2) / max(len(apis1), len(apis2)) if apis1 or apis2 else 0
        
        # æ¯”è¼ƒä½¿ç”¨çš„æŠ€è¡“
        tech1 = set(fp1.get('technologies', []))
        tech2 = set(fp2.get('technologies', []))
        
        tech_sim = len(tech1 & tech2) / max(len(tech1), len(tech2)) if tech1 or tech2 else 0
        
        return (api_sim + tech_sim) / 2
    
    def _compare_dicts(self, d1: Dict, d2: Dict) -> float:
        """æ¯”è¼ƒå­—å…¸ç›¸ä¼¼åº¦"""
        if not d1 or not d2:
            return 0.0
        
        all_keys = set(d1.keys()) | set(d2.keys())
        if not all_keys:
            return 0.0
        
        matching = sum(1 for k in all_keys if d1.get(k) == d2.get(k))
        return matching / len(all_keys)
    
    def _generate_details(self, fp1: Dict, fp2: Dict, scores: Dict) -> Dict:
        """ç”Ÿæˆè©³ç´°æ¯”è¼ƒçµæœ"""
        return {
            'common_technologies': list(
                set(fp1.get('technologies', [])) & 
                set(fp2.get('technologies', []))
            ),
            'unique_to_first': list(
                set(fp1.get('technologies', [])) - 
                set(fp2.get('technologies', []))
            ),
            'unique_to_second': list(
                set(fp2.get('technologies', [])) - 
                set(fp1.get('technologies', []))
            ),
            'score_breakdown': scores
        }

# ä½¿ç”¨ç¯„ä¾‹
calculator = FingerprintSimilarityCalculator()

# æº–å‚™å…©å€‹ç¶²ç«™çš„æŒ‡ç´‹
fingerprint1 = {
    'dom_tags': ['div', 'span', 'img', 'a'],
    'dom_depth': 8,
    'dominant_colors': ['#ffffff', '#000000', '#ff0000'],
    'technologies': ['React', 'Redux', 'Axios'],
    'api_endpoints': ['/api/users', '/api/posts']
}

fingerprint2 = {
    'dom_tags': ['div', 'span', 'p', 'a'],
    'dom_depth': 7,
    'dominant_colors': ['#ffffff', '#000000', '#0000ff'],
    'technologies': ['React', 'MobX', 'Axios'],
    'api_endpoints': ['/api/users', '/api/comments']
}

# è¨ˆç®—ç›¸ä¼¼åº¦
similarity = calculator.calculate(fingerprint1, fingerprint2)

print(f"æ•´é«”ç›¸ä¼¼åº¦: {similarity.overall:.2%}")
print(f"çµæ§‹ç›¸ä¼¼åº¦: {similarity.structural:.2%}")
print(f"è¦–è¦ºç›¸ä¼¼åº¦: {similarity.visual:.2%}")
print(f"å…§å®¹ç›¸ä¼¼åº¦: {similarity.content:.2%}")
print(f"è¡Œç‚ºç›¸ä¼¼åº¦: {similarity.behavioral:.2%}")
print(f"\nå…±åŒæŠ€è¡“: {similarity.details['common_technologies']}")
```

---

## ğŸ”— ç›¸é—œè³‡æº

- [2.4 æ ¸å¿ƒçµ„ä»¶è©³ç´°å¯¦ç¾](ch2-4-æ ¸å¿ƒçµ„ä»¶è©³ç´°å¯¦ç¾.md)
- [2.6 APIè©³ç´°è¦ç¯„](ch2-6-APIè©³ç´°è¦ç¯„.md)
- [2.11 æ•…éšœæ’æŸ¥æŒ‡å—](ch2-11-æ•…éšœæ’æŸ¥æŒ‡å—.md)
- [â† è¿”å›ç¬¬2ç« é¦–é ](ch2-index.md)

