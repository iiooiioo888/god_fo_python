# 第2章：網站指紋分析引擎 (Website Fingerprint Engine)

## 2.12 實戰範例集

**[← 返回第2章首頁](ch2-index.md)**

---

本章節提供網站指紋分析引擎的實際應用範例。

## 🎯 範例索引

| 範例編號 | 名稱 | 難度 | 場景 |
|---------|------|------|------|
| 1 | 基礎指紋識別 | ⭐⭐ | 網站類型識別 |
| 2 | 自定義指紋規則 | ⭐⭐⭐ | 規則開發 |
| 3 | 批量網站分析 | ⭐⭐⭐ | 大規模掃描 |
| 4 | 動態網站指紋 | ⭐⭐⭐⭐ | JS渲染分析 |
| 5 | 指紋相似度計算 | ⭐⭐⭐⭐ | 相似性分析 |
| 6 | 智能指紋學習 | ⭐⭐⭐⭐⭐ | 機器學習 |

---

## 範例 1: 基礎指紋識別系統

### 場景描述
實現一個完整的網站指紋識別系統，能夠識別常見的 CMS 和框架。

### 完整實現

```python
import requests
from bs4 import BeautifulSoup
from typing import Dict, List, Optional
import re
from dataclasses import dataclass
from enum import Enum

class WebsiteType(Enum):
    """網站類型"""
    WORDPRESS = "WordPress"
    DRUPAL = "Drupal"
    JOOMLA = "Joomla"
    SHOPIFY = "Shopify"
    WOOCOMMERCE = "WooCommerce"
    MAGENTO = "Magento"
    DJANGO = "Django"
    LARAVEL = "Laravel"
    REACT = "React"
    VUE = "Vue.js"
    ANGULAR = "Angular"
    UNKNOWN = "Unknown"

@dataclass
class FingerprintMatch:
    """指紋匹配結果"""
    website_type: WebsiteType
    confidence: float
    matched_features: List[str]
    evidence: Dict[str, any]

class BasicFingerprintDetector:
    """基礎指紋檢測器"""
    
    def __init__(self):
        self.rules = self._load_rules()
    
    def _load_rules(self) -> Dict:
        """載入指紋規則"""
        return {
            WebsiteType.WORDPRESS: {
                'meta_tags': ['generator=WordPress'],
                'paths': ['/wp-content/', '/wp-includes/', '/wp-admin/'],
                'headers': {},
                'scripts': ['wp-embed.min.js', 'wp-emoji-release.min.js'],
                'cookies': ['wordpress_', 'wp-settings']
            },
            WebsiteType.DRUPAL: {
                'meta_tags': ['generator=Drupal'],
                'paths': ['/sites/default/', '/modules/', '/themes/'],
                'headers': {'X-Drupal-Cache': '*'},
                'scripts': ['drupal.js'],
                'cookies': ['SESS']
            },
            WebsiteType.SHOPIFY: {
                'meta_tags': [],
                'paths': ['/cdn.shopify.com/'],
                'headers': {'X-ShopId': '*'},
                'scripts': ['shopify'],
                'cookies': ['_shopify_']
            },
            WebsiteType.REACT: {
                'meta_tags': [],
                'paths': [],
                'headers': {},
                'scripts': ['react', 'react-dom'],
                'dom_attributes': ['data-reactroot', 'data-reactid']
            },
            WebsiteType.VUE: {
                'meta_tags': [],
                'paths': [],
                'headers': {},
                'scripts': ['vue.js', 'vue.min.js'],
                'dom_attributes': ['data-v-', 'v-cloak']
            }
        }
    
    def detect(self, url: str) -> FingerprintMatch:
        """檢測網站指紋"""
        try:
            # 獲取網頁內容
            response = requests.get(url, timeout=10, headers={
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            })
            
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # 提取特徵
            features = {
                'html': response.text,
                'headers': dict(response.headers),
                'cookies': response.cookies,
                'soup': soup
            }
            
            # 嘗試匹配每個規則
            matches = []
            for website_type, rules in self.rules.items():
                match_result = self._match_rules(features, rules, website_type)
                if match_result.confidence > 0:
                    matches.append(match_result)
            
            # 返回最佳匹配
            if matches:
                matches.sort(key=lambda x: x.confidence, reverse=True)
                return matches[0]
            
            return FingerprintMatch(
                website_type=WebsiteType.UNKNOWN,
                confidence=0.0,
                matched_features=[],
                evidence={}
            )
            
        except Exception as e:
            raise Exception(f"檢測失敗: {str(e)}")
    
    def _match_rules(self, features: Dict, rules: Dict, website_type: WebsiteType) -> FingerprintMatch:
        """匹配規則"""
        matched_features = []
        evidence = {}
        score = 0.0
        max_score = 0.0
        
        # 檢查 meta 標籤
        if 'meta_tags' in rules:
            max_score += 0.3
            for tag_pattern in rules['meta_tags']:
                meta = features['soup'].find('meta', attrs={'name': 'generator'})
                if meta and tag_pattern.split('=')[1] in meta.get('content', ''):
                    matched_features.append(f"meta: {tag_pattern}")
                    evidence['meta'] = meta.get('content')
                    score += 0.3
                    break
        
        # 檢查路徑
        if 'paths' in rules:
            max_score += 0.3
            html = features['html']
            for path in rules['paths']:
                if path in html:
                    matched_features.append(f"path: {path}")
                    evidence.setdefault('paths', []).append(path)
                    score += 0.3 / len(rules['paths'])
        
        # 檢查腳本
        if 'scripts' in rules:
            max_score += 0.2
            scripts = features['soup'].find_all('script', src=True)
            for script in scripts:
                src = script.get('src', '')
                for script_pattern in rules['scripts']:
                    if script_pattern in src:
                        matched_features.append(f"script: {script_pattern}")
                        evidence.setdefault('scripts', []).append(src)
                        score += 0.2 / len(rules['scripts'])
                        break
        
        # 檢查 headers
        if 'headers' in rules:
            max_score += 0.1
            for header_key, header_value in rules['headers'].items():
                if header_key in features['headers']:
                    matched_features.append(f"header: {header_key}")
                    evidence['headers'] = {header_key: features['headers'][header_key]}
                    score += 0.1
        
        # 檢查 DOM 屬性
        if 'dom_attributes' in rules:
            max_score += 0.1
            html = features['html']
            for attr in rules['dom_attributes']:
                if attr in html:
                    matched_features.append(f"dom: {attr}")
                    evidence.setdefault('dom_attributes', []).append(attr)
                    score += 0.1 / len(rules['dom_attributes'])
        
        confidence = score / max_score if max_score > 0 else 0.0
        
        return FingerprintMatch(
            website_type=website_type,
            confidence=confidence,
            matched_features=matched_features,
            evidence=evidence
        )
    
    def batch_detect(self, urls: List[str]) -> List[Dict]:
        """批量檢測"""
        results = []
        
        for url in urls:
            try:
                match = self.detect(url)
                results.append({
                    'url': url,
                    'type': match.website_type.value,
                    'confidence': match.confidence,
                    'features': match.matched_features,
                    'success': True
                })
            except Exception as e:
                results.append({
                    'url': url,
                    'error': str(e),
                    'success': False
                })
        
        return results

# 使用範例
detector = BasicFingerprintDetector()

# 檢測單個網站
match = detector.detect("https://wordpress-site.com")
print(f"網站類型: {match.website_type.value}")
print(f"置信度: {match.confidence:.2%}")
print(f"匹配特徵: {match.matched_features}")

# 批量檢測
urls = [
    "https://site1.com",
    "https://site2.com",
    "https://site3.com"
]
results = detector.batch_detect(urls)

# 生成報告
import pandas as pd
df = pd.DataFrame(results)
df.to_excel("fingerprint_results.xlsx", index=False)
```

---

## 範例 2: 動態網站指紋分析

### 場景描述
處理需要 JavaScript 渲染的現代 SPA (Single Page Application) 網站。

### 完整實現

```python
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time
import json

class DynamicFingerprintAnalyzer:
    """動態網站指紋分析器"""
    
    def __init__(self, headless=True):
        self.headless = headless
        self.driver = None
    
    def _init_driver(self):
        """初始化瀏覽器"""
        options = Options()
        if self.headless:
            options.add_argument('--headless')
        options.add_argument('--disable-gpu')
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        
        # 禁用圖片載入以加速
        prefs = {
            'profile.managed_default_content_settings.images': 2,
            'profile.default_content_setting_values.notifications': 2
        }
        options.add_experimental_option('prefs', prefs)
        
        self.driver = webdriver.Chrome(options=options)
        self.driver.set_page_load_timeout(30)
    
    def analyze(self, url: str) -> Dict:
        """分析動態網站"""
        if not self.driver:
            self._init_driver()
        
        try:
            # 載入頁面
            self.driver.get(url)
            
            # 等待 JavaScript 執行
            time.sleep(3)
            
            # 提取特徵
            features = {
                'framework': self._detect_framework(),
                'libraries': self._detect_libraries(),
                'api_calls': self._capture_api_calls(),
                'websockets': self._detect_websockets(),
                'spa_indicators': self._detect_spa_indicators(),
                'dom_structure': self._analyze_dom_structure(),
                'performance': self._get_performance_metrics()
            }
            
            return features
            
        except Exception as e:
            raise Exception(f"分析失敗: {str(e)}")
    
    def _detect_framework(self) -> Dict:
        """檢測前端框架"""
        frameworks = {}
        
        # 檢測 React
        react_check = self.driver.execute_script("""
            return {
                hasReact: typeof React !== 'undefined',
                hasReactDOM: typeof ReactDOM !== 'undefined',
                version: typeof React !== 'undefined' ? React.version : null,
                devTools: window.__REACT_DEVTOOLS_GLOBAL_HOOK__ !== undefined
            };
        """)
        if react_check['hasReact']:
            frameworks['React'] = react_check
        
        # 檢測 Vue
        vue_check = self.driver.execute_script("""
            return {
                hasVue: typeof Vue !== 'undefined',
                version: typeof Vue !== 'undefined' ? Vue.version : null,
                devTools: window.__VUE_DEVTOOLS_GLOBAL_HOOK__ !== undefined,
                apps: document.querySelectorAll('[data-v-app]').length
            };
        """)
        if vue_check['hasVue']:
            frameworks['Vue'] = vue_check
        
        # 檢測 Angular
        angular_check = self.driver.execute_script("""
            return {
                hasAngular: typeof angular !== 'undefined' || document.querySelector('[ng-version]') !== null,
                version: document.querySelector('[ng-version]')?.getAttribute('ng-version'),
                isAngularJS: typeof angular !== 'undefined'
            };
        """)
        if angular_check['hasAngular']:
            frameworks['Angular'] = angular_check
        
        return frameworks
    
    def _detect_libraries(self) -> List[str]:
        """檢測使用的 JavaScript 庫"""
        libraries = self.driver.execute_script("""
            const libs = [];
            
            // 常見庫檢測
            if (typeof jQuery !== 'undefined') libs.push(`jQuery ${jQuery.fn.jquery}`);
            if (typeof _ !== 'undefined') libs.push('Lodash');
            if (typeof moment !== 'undefined') libs.push('Moment.js');
            if (typeof axios !== 'undefined') libs.push('Axios');
            if (typeof $ !== 'undefined' && typeof $.fn.modal !== 'undefined') libs.push('Bootstrap');
            
            return libs;
        """)
        
        return libraries
    
    def _capture_api_calls(self) -> List[Dict]:
        """捕獲 API 調用"""
        # 獲取網路請求日誌
        logs = self.driver.get_log('performance')
        api_calls = []
        
        for log in logs:
            message = json.loads(log['message'])
            method = message.get('message', {}).get('method', '')
            
            if 'Network.responseReceived' in method:
                response = message.get('message', {}).get('params', {}).get('response', {})
                url = response.get('url', '')
                
                # 過濾 API 調用
                if any(pattern in url for pattern in ['/api/', '/graphql', '.json', '/rest/']):
                    api_calls.append({
                        'url': url,
                        'method': response.get('method'),
                        'status': response.get('status'),
                        'mimeType': response.get('mimeType')
                    })
        
        return api_calls
    
    def _detect_websockets(self) -> Dict:
        """檢測 WebSocket 使用"""
        ws_info = self.driver.execute_script("""
            return {
                hasWebSocket: typeof WebSocket !== 'undefined',
                connections: performance.getEntriesByType('resource')
                    .filter(r => r.name.startsWith('ws://') || r.name.startsWith('wss://'))
                    .map(r => r.name)
            };
        """)
        
        return ws_info
    
    def _detect_spa_indicators(self) -> Dict:
        """檢測 SPA 特徵"""
        indicators = self.driver.execute_script("""
            return {
                hasRouter: window.location.hash.includes('#/') || history.pushState !== undefined,
                hasVirtualDOM: document.querySelector('[data-reactroot], [data-reactid], [data-v-]') !== null,
                dynamicContent: document.querySelector('[data-dynamic], [data-bind]') !== null,
                lazyLoading: document.querySelector('[loading="lazy"]') !== null
            };
        """)
        
        return indicators
    
    def _analyze_dom_structure(self) -> Dict:
        """分析 DOM 結構"""
        structure = self.driver.execute_script("""
            function getDOMDepth(element) {
                let maxDepth = 0;
                for (let child of element.children) {
                    maxDepth = Math.max(maxDepth, getDOMDepth(child));
                }
                return maxDepth + 1;
            }
            
            return {
                depth: getDOMDepth(document.body),
                elementCount: document.querySelectorAll('*').length,
                scriptTags: document.querySelectorAll('script').length,
                styleTags: document.querySelectorAll('style, link[rel="stylesheet"]').length
            };
        """)
        
        return structure
    
    def _get_performance_metrics(self) -> Dict:
        """獲取效能指標"""
        metrics = self.driver.execute_script("""
            const perfData = window.performance.timing;
            const navigation = performance.getEntriesByType('navigation')[0];
            
            return {
                loadTime: perfData.loadEventEnd - perfData.navigationStart,
                domReady: perfData.domContentLoadedEventEnd - perfData.navigationStart,
                firstPaint: navigation ? navigation.responseStart - navigation.requestStart : 0,
                resources: performance.getEntriesByType('resource').length
            };
        """)
        
        return metrics
    
    def close(self):
        """關閉瀏覽器"""
        if self.driver:
            self.driver.quit()
            self.driver = None

# 使用範例
analyzer = DynamicFingerprintAnalyzer(headless=True)

try:
    # 分析 React 應用
    features = analyzer.analyze("https://react-app.com")
    
    print("檢測到的框架:")
    for framework, details in features['framework'].items():
        print(f"  {framework}: {details}")
    
    print(f"\n使用的庫: {', '.join(features['libraries'])}")
    print(f"API 調用數: {len(features['api_calls'])}")
    print(f"DOM 深度: {features['dom_structure']['depth']}")
    print(f"載入時間: {features['performance']['loadTime']}ms")
    
finally:
    analyzer.close()
```

---

## 範例 3: 指紋相似度比較系統

### 場景描述
比較兩個網站的指紋相似度，用於識別鏡像站點或相似網站。

### 完整實現

```python
from typing import Set, Dict, List
from dataclasses import dataclass
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

@dataclass
class SimilarityScore:
    """相似度得分"""
    overall: float
    structural: float
    visual: float
    content: float
    behavioral: float
    details: Dict

class FingerprintSimilarityCalculator:
    """指紋相似度計算器"""
    
    def __init__(self):
        self.vectorizer = TfidfVectorizer()
    
    def calculate(self, fingerprint1: Dict, fingerprint2: Dict) -> SimilarityScore:
        """計算兩個指紋的相似度"""
        
        scores = {
            'structural': self._compare_structure(fingerprint1, fingerprint2),
            'visual': self._compare_visual(fingerprint1, fingerprint2),
            'content': self._compare_content(fingerprint1, fingerprint2),
            'behavioral': self._compare_behavioral(fingerprint1, fingerprint2)
        }
        
        # 加權平均
        weights = {
            'structural': 0.3,
            'visual': 0.2,
            'content': 0.3,
            'behavioral': 0.2
        }
        
        overall = sum(scores[k] * weights[k] for k in scores)
        
        return SimilarityScore(
            overall=overall,
            structural=scores['structural'],
            visual=scores['visual'],
            content=scores['content'],
            behavioral=scores['behavioral'],
            details=self._generate_details(fingerprint1, fingerprint2, scores)
        )
    
    def _compare_structure(self, fp1: Dict, fp2: Dict) -> float:
        """比較結構相似度"""
        # 比較 DOM 結構
        dom1 = set(fp1.get('dom_tags', []))
        dom2 = set(fp2.get('dom_tags', []))
        
        # Jaccard 相似度
        intersection = len(dom1 & dom2)
        union = len(dom1 | dom2)
        
        jaccard = intersection / union if union > 0 else 0
        
        # 比較層次結構
        depth_diff = abs(fp1.get('dom_depth', 0) - fp2.get('dom_depth', 0))
        depth_sim = 1 / (1 + depth_diff / 10)  # 標準化
        
        return (jaccard + depth_sim) / 2
    
    def _compare_visual(self, fp1: Dict, fp2: Dict) -> float:
        """比較視覺相似度"""
        # 比較顏色分布
        colors1 = set(fp1.get('dominant_colors', []))
        colors2 = set(fp2.get('dominant_colors', []))
        
        color_sim = len(colors1 & colors2) / max(len(colors1), len(colors2)) if colors1 or colors2 else 0
        
        # 比較布局相似度
        layout1 = fp1.get('layout_structure', {})
        layout2 = fp2.get('layout_structure', {})
        
        layout_sim = self._compare_dicts(layout1, layout2)
        
        return (color_sim + layout_sim) / 2
    
    def _compare_content(self, fp1: Dict, fp2: Dict) -> float:
        """比較內容相似度"""
        text1 = fp1.get('text_content', '')
        text2 = fp2.get('text_content', '')
        
        if not text1 or not text2:
            return 0.0
        
        # 使用 TF-IDF 和餘弦相似度
        try:
            vectors = self.vectorizer.fit_transform([text1, text2])
            similarity = cosine_similarity(vectors[0:1], vectors[1:2])[0][0]
            return similarity
        except:
            return 0.0
    
    def _compare_behavioral(self, fp1: Dict, fp2: Dict) -> float:
        """比較行為相似度"""
        # 比較 API 端點
        apis1 = set(fp1.get('api_endpoints', []))
        apis2 = set(fp2.get('api_endpoints', []))
        
        api_sim = len(apis1 & apis2) / max(len(apis1), len(apis2)) if apis1 or apis2 else 0
        
        # 比較使用的技術
        tech1 = set(fp1.get('technologies', []))
        tech2 = set(fp2.get('technologies', []))
        
        tech_sim = len(tech1 & tech2) / max(len(tech1), len(tech2)) if tech1 or tech2 else 0
        
        return (api_sim + tech_sim) / 2
    
    def _compare_dicts(self, d1: Dict, d2: Dict) -> float:
        """比較字典相似度"""
        if not d1 or not d2:
            return 0.0
        
        all_keys = set(d1.keys()) | set(d2.keys())
        if not all_keys:
            return 0.0
        
        matching = sum(1 for k in all_keys if d1.get(k) == d2.get(k))
        return matching / len(all_keys)
    
    def _generate_details(self, fp1: Dict, fp2: Dict, scores: Dict) -> Dict:
        """生成詳細比較結果"""
        return {
            'common_technologies': list(
                set(fp1.get('technologies', [])) & 
                set(fp2.get('technologies', []))
            ),
            'unique_to_first': list(
                set(fp1.get('technologies', [])) - 
                set(fp2.get('technologies', []))
            ),
            'unique_to_second': list(
                set(fp2.get('technologies', [])) - 
                set(fp1.get('technologies', []))
            ),
            'score_breakdown': scores
        }

# 使用範例
calculator = FingerprintSimilarityCalculator()

# 準備兩個網站的指紋
fingerprint1 = {
    'dom_tags': ['div', 'span', 'img', 'a'],
    'dom_depth': 8,
    'dominant_colors': ['#ffffff', '#000000', '#ff0000'],
    'technologies': ['React', 'Redux', 'Axios'],
    'api_endpoints': ['/api/users', '/api/posts']
}

fingerprint2 = {
    'dom_tags': ['div', 'span', 'p', 'a'],
    'dom_depth': 7,
    'dominant_colors': ['#ffffff', '#000000', '#0000ff'],
    'technologies': ['React', 'MobX', 'Axios'],
    'api_endpoints': ['/api/users', '/api/comments']
}

# 計算相似度
similarity = calculator.calculate(fingerprint1, fingerprint2)

print(f"整體相似度: {similarity.overall:.2%}")
print(f"結構相似度: {similarity.structural:.2%}")
print(f"視覺相似度: {similarity.visual:.2%}")
print(f"內容相似度: {similarity.content:.2%}")
print(f"行為相似度: {similarity.behavioral:.2%}")
print(f"\n共同技術: {similarity.details['common_technologies']}")
```

---

## 🔗 相關資源

- [2.4 核心組件詳細實現](ch2-4-核心組件詳細實現.md)
- [2.6 API詳細規範](ch2-6-API詳細規範.md)
- [2.11 故障排查指南](ch2-11-故障排查指南.md)
- [← 返回第2章首頁](ch2-index.md)

