# ç¬¬7ç« ï¼šè³‡æ–™åˆè¦èˆ‡å®‰å…¨ä¸­å¿ƒ (Data Compliance and Security Center)

## 7.11 æ•…éšœæ’æŸ¥æŒ‡å—

**[â† è¿”å›ç¬¬7ç« é¦–é ](ch7-index.md)**

---

æœ¬ç« ç¯€æä¾›è³‡æ–™åˆè¦èˆ‡å®‰å…¨ä¸­å¿ƒå¸¸è¦‹å•é¡Œçš„è¨ºæ–·å’Œè§£æ±ºæ–¹æ¡ˆã€‚

## ğŸ” å•é¡Œè¨ºæ–·æµç¨‹

```mermaid
graph TD
    A[åˆè¦/å®‰å…¨å•é¡Œ] --> B{å•é¡Œé¡å‹?}
    B -->|åˆè¦æª¢æŸ¥å¤±æ•—| C[æª¢æŸ¥è¦å‰‡é…ç½®]
    B -->|è³‡æ–™æ´©æ¼| D[å¯©è¨ˆæ—¥èªŒåˆ†æ]
    B -->|åŠ å¯†å¤±æ•—| E[æª¢æŸ¥å¯†é‘°ç®¡ç†]
    C --> F[å®šä½å•é¡Œè¦å‰‡]
    D --> G[è¿½è¹¤è³‡æ–™æµå‘]
    E --> H[é©—è­‰åŠ å¯†é…ç½®]
    F --> I[æ‡‰ç”¨è§£æ±ºæ–¹æ¡ˆ]
    G --> I
    H --> I
```

---

## ğŸ› å¸¸è¦‹å•é¡Œèˆ‡è§£æ±ºæ–¹æ¡ˆ

### å•é¡Œ 1: åˆè¦æª¢æŸ¥å¤±æ•—

#### ç—‡ç‹€
- è³‡æ–™è™•ç†è¢«é˜»æ“‹
- åˆè¦å ±å‘Šé¡¯ç¤ºé•è¦
- å¤§é‡åˆè¦å‘Šè­¦

#### è¨ºæ–·å·¥å…·

```python
class ComplianceDiagnostics:
    """åˆè¦è¨ºæ–·å·¥å…·"""
    
    def __init__(self, compliance_engine):
        self.engine = compliance_engine
        self.logger = logging.getLogger(__name__)
    
    def diagnose_compliance_failure(
        self,
        data_source: str,
        operation: str
    ) -> Dict:
        """è¨ºæ–·åˆè¦æª¢æŸ¥å¤±æ•—"""
        diagnostics = {
            'data_source': data_source,
            'operation': operation,
            'failed_rules': [],
            'recommendations': [],
            'risk_level': 'unknown'
        }
        
        # ç²å–é©ç”¨çš„åˆè¦è¦å‰‡
        rules = self.engine.get_applicable_rules(data_source, operation)
        
        # æª¢æŸ¥æ¯å€‹è¦å‰‡
        for rule in rules:
            try:
                result = self.engine.check_rule(rule, data_source, operation)
                
                if not result['passed']:
                    diagnostics['failed_rules'].append({
                        'rule_id': rule.id,
                        'rule_name': rule.name,
                        'category': rule.category,
                        'reason': result['reason'],
                        'severity': rule.severity
                    })
            except Exception as e:
                self.logger.error(f"è¦å‰‡æª¢æŸ¥å¤±æ•— {rule.id}: {str(e)}")
        
        # è©•ä¼°é¢¨éšªç­‰ç´š
        diagnostics['risk_level'] = self._calculate_risk_level(
            diagnostics['failed_rules']
        )
        
        # ç”Ÿæˆå»ºè­°
        diagnostics['recommendations'] = self._generate_recommendations(
            diagnostics['failed_rules']
        )
        
        return diagnostics
    
    def _calculate_risk_level(self, failed_rules: List[Dict]) -> str:
        """è¨ˆç®—é¢¨éšªç­‰ç´š"""
        if not failed_rules:
            return 'none'
        
        severities = [rule['severity'] for rule in failed_rules]
        
        if 'critical' in severities:
            return 'critical'
        elif 'high' in severities:
            return 'high'
        elif 'medium' in severities:
            return 'medium'
        else:
            return 'low'
    
    def _generate_recommendations(self, failed_rules: List[Dict]) -> List[str]:
        """ç”Ÿæˆä¿®å¾©å»ºè­°"""
        recommendations = []
        
        # æŒ‰é¡åˆ¥åˆ†çµ„
        by_category = {}
        for rule in failed_rules:
            category = rule['category']
            if category not in by_category:
                by_category[category] = []
            by_category[category].append(rule)
        
        # é‡å°æ¯å€‹é¡åˆ¥ç”Ÿæˆå»ºè­°
        for category, rules in by_category.items():
            if category == 'data_classification':
                recommendations.append(
                    "æª¢æŸ¥è³‡æ–™åˆ†é¡é…ç½®ï¼Œç¢ºä¿æ•æ„Ÿè³‡æ–™è¢«æ­£ç¢ºæ¨™è¨˜"
                )
            elif category == 'access_control':
                recommendations.append(
                    "å¯©æŸ¥è¨ªå•æ¬Šé™é…ç½®ï¼Œå¯¦æ–½æœ€å°æ¬Šé™åŸå‰‡"
                )
            elif category == 'encryption':
                recommendations.append(
                    "å•Ÿç”¨è³‡æ–™åŠ å¯†ï¼Œä½¿ç”¨ç¬¦åˆæ¨™æº–çš„åŠ å¯†æ¼”ç®—æ³•"
                )
            elif category == 'audit':
                recommendations.append(
                    "ç¢ºä¿å¯©è¨ˆæ—¥èªŒå®Œæ•´è¨˜éŒ„æ‰€æœ‰æ•æ„Ÿæ“ä½œ"
                )
        
        return recommendations

# ä½¿ç”¨ç¯„ä¾‹
diagnostics = ComplianceDiagnostics(compliance_engine)
result = diagnostics.diagnose_compliance_failure(
    data_source="user_database",
    operation="export"
)

print(f"é¢¨éšªç­‰ç´š: {result['risk_level']}")
print(f"å¤±æ•—çš„è¦å‰‡æ•¸: {len(result['failed_rules'])}")

for rule in result['failed_rules']:
    print(f"\nè¦å‰‡: {rule['rule_name']}")
    print(f"  é¡åˆ¥: {rule['category']}")
    print(f"  åŸå› : {rule['reason']}")
    print(f"  åš´é‡æ€§: {rule['severity']}")

print(f"\nå»ºè­°:")
for rec in result['recommendations']:
    print(f"  - {rec}")
```

#### è§£æ±ºæ–¹æ¡ˆ

**æ–¹æ¡ˆ 1: å¯¦ç¾åˆ†ç´šåˆè¦æª¢æŸ¥**

```python
class TieredComplianceChecker:
    """åˆ†ç´šåˆè¦æª¢æŸ¥å™¨"""
    
    def __init__(self):
        self.rules_by_tier = {
            'critical': [],  # å¿…é ˆé€šé
            'important': [], # å»ºè­°é€šé
            'optional': []   # å¯é¸
        }
    
    def register_rule(self, rule, tier='important'):
        """è¨»å†Šåˆè¦è¦å‰‡"""
        if tier not in self.rules_by_tier:
            raise ValueError(f"ç„¡æ•ˆçš„å±¤ç´š: {tier}")
        
        self.rules_by_tier[tier].append(rule)
    
    def check_compliance(
        self,
        data_source: str,
        operation: str,
        strict_mode: bool = False
    ) -> Dict:
        """åŸ·è¡Œåˆè¦æª¢æŸ¥"""
        results = {
            'passed': True,
            'tier_results': {},
            'failed_rules': [],
            'warnings': []
        }
        
        # æª¢æŸ¥é—œéµè¦å‰‡
        critical_result = self._check_tier(
            'critical',
            data_source,
            operation
        )
        results['tier_results']['critical'] = critical_result
        
        if not critical_result['passed']:
            results['passed'] = False
            results['failed_rules'].extend(critical_result['failed'])
            return results  # é—œéµè¦å‰‡å¤±æ•—ï¼Œç«‹å³è¿”å›
        
        # æª¢æŸ¥é‡è¦è¦å‰‡
        important_result = self._check_tier(
            'important',
            data_source,
            operation
        )
        results['tier_results']['important'] = important_result
        
        if not important_result['passed']:
            if strict_mode:
                results['passed'] = False
                results['failed_rules'].extend(important_result['failed'])
            else:
                # éåš´æ ¼æ¨¡å¼ï¼Œåªè¨˜éŒ„è­¦å‘Š
                results['warnings'].extend(important_result['failed'])
        
        # æª¢æŸ¥å¯é¸è¦å‰‡
        optional_result = self._check_tier(
            'optional',
            data_source,
            operation
        )
        results['tier_results']['optional'] = optional_result
        
        if not optional_result['passed']:
            results['warnings'].extend(optional_result['failed'])
        
        return results
    
    def _check_tier(
        self,
        tier: str,
        data_source: str,
        operation: str
    ) -> Dict:
        """æª¢æŸ¥ç‰¹å®šå±¤ç´šçš„è¦å‰‡"""
        result = {
            'passed': True,
            'checked': 0,
            'failed': []
        }
        
        for rule in self.rules_by_tier[tier]:
            result['checked'] += 1
            
            try:
                if not rule.check(data_source, operation):
                    result['passed'] = False
                    result['failed'].append({
                        'rule_id': rule.id,
                        'rule_name': rule.name,
                        'reason': rule.get_failure_reason()
                    })
            except Exception as e:
                self.logger.error(f"è¦å‰‡æª¢æŸ¥éŒ¯èª¤: {str(e)}")
                result['passed'] = False
                result['failed'].append({
                    'rule_id': rule.id,
                    'rule_name': rule.name,
                    'reason': f"æª¢æŸ¥éŒ¯èª¤: {str(e)}"
                })
        
        return result
```

**æ–¹æ¡ˆ 2: å¯¦ç¾åˆè¦è¦å‰‡å¿«å–**

```python
class CachedComplianceChecker:
    """å¸¶å¿«å–çš„åˆè¦æª¢æŸ¥å™¨"""
    
    def __init__(self, cache_ttl=300):
        self.cache_ttl = cache_ttl
        self.cache = {}
        self.cache_stats = {
            'hits': 0,
            'misses': 0
        }
    
    def check_compliance(
        self,
        data_source: str,
        operation: str,
        use_cache: bool = True
    ) -> Dict:
        """åŸ·è¡Œåˆè¦æª¢æŸ¥ï¼ˆå¸¶å¿«å–ï¼‰"""
        cache_key = self._generate_cache_key(data_source, operation)
        
        # å˜—è©¦å¾å¿«å–ç²å–
        if use_cache:
            cached_result = self._get_from_cache(cache_key)
            if cached_result:
                self.cache_stats['hits'] += 1
                return cached_result
        
        self.cache_stats['misses'] += 1
        
        # åŸ·è¡Œå¯¦éš›æª¢æŸ¥
        result = self._perform_check(data_source, operation)
        
        # å­˜å…¥å¿«å–
        if use_cache and result['cacheable']:
            self._put_to_cache(cache_key, result)
        
        return result
    
    def _generate_cache_key(self, data_source: str, operation: str) -> str:
        """ç”Ÿæˆå¿«å–éµ"""
        return f"compliance:{data_source}:{operation}"
    
    def _get_from_cache(self, cache_key: str) -> Optional[Dict]:
        """å¾å¿«å–ç²å–çµæœ"""
        if cache_key not in self.cache:
            return None
        
        cached = self.cache[cache_key]
        
        # æª¢æŸ¥æ˜¯å¦éæœŸ
        if time.time() - cached['timestamp'] > self.cache_ttl:
            del self.cache[cache_key]
            return None
        
        return cached['result']
    
    def _put_to_cache(self, cache_key: str, result: Dict):
        """å°‡çµæœå­˜å…¥å¿«å–"""
        self.cache[cache_key] = {
            'result': result,
            'timestamp': time.time()
        }
```

---

### å•é¡Œ 2: æ•æ„Ÿè³‡æ–™æ´©æ¼

#### ç—‡ç‹€
- å¯©è¨ˆæ—¥èªŒé¡¯ç¤ºç•°å¸¸è¨ªå•
- æ•æ„Ÿè³‡æ–™å‡ºç¾åœ¨æ—¥èªŒä¸­
- æœªæˆæ¬Šçš„è³‡æ–™å°å‡º

#### è¨ºæ–·å·¥å…·

```python
class DataLeakageDetector:
    """è³‡æ–™æ´©æ¼æª¢æ¸¬å™¨"""
    
    def __init__(self):
        self.sensitive_patterns = self._load_sensitive_patterns()
        self.anomaly_detector = AnomalyDetector()
    
    def _load_sensitive_patterns(self) -> List[Pattern]:
        """è¼‰å…¥æ•æ„Ÿè³‡æ–™æ¨¡å¼"""
        return [
            re.compile(r'\b\d{15,19}\b'),  # ä¿¡ç”¨å¡è™Ÿ
            re.compile(r'\b\d{3}-\d{2}-\d{4}\b'),  # SSN
            re.compile(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'),  # Email
            re.compile(r'\b09\d{8}\b'),  # å°ç£æ‰‹æ©Ÿè™Ÿç¢¼
        ]
    
    def scan_logs_for_leakage(
        self,
        log_file: str,
        time_range: tuple = None
    ) -> Dict:
        """æƒææ—¥èªŒå°‹æ‰¾æ´©æ¼"""
        findings = {
            'leaks_found': 0,
            'details': [],
            'severity': 'none'
        }
        
        with open(log_file, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                # æª¢æŸ¥æ¯å€‹æ•æ„Ÿæ¨¡å¼
                for pattern in self.sensitive_patterns:
                    matches = pattern.findall(line)
                    if matches:
                        findings['leaks_found'] += len(matches)
                        findings['details'].append({
                            'line': line_num,
                            'pattern': pattern.pattern,
                            'matches': matches,
                            'context': line[:100]  # åªä¿ç•™éƒ¨åˆ†ä¸Šä¸‹æ–‡
                        })
        
        # è©•ä¼°åš´é‡æ€§
        if findings['leaks_found'] > 100:
            findings['severity'] = 'critical'
        elif findings['leaks_found'] > 10:
            findings['severity'] = 'high'
        elif findings['leaks_found'] > 0:
            findings['severity'] = 'medium'
        
        return findings
    
    def detect_anomalous_access(
        self,
        user_id: str,
        access_logs: List[Dict]
    ) -> Dict:
        """æª¢æ¸¬ç•°å¸¸è¨ªå•è¡Œç‚º"""
        analysis = {
            'is_anomalous': False,
            'anomalies': [],
            'risk_score': 0
        }
        
        # åˆ†æè¨ªå•æ¨¡å¼
        access_pattern = self._analyze_access_pattern(access_logs)
        
        # æª¢æ¸¬ç•°å¸¸
        # 1. éå·¥ä½œæ™‚é–“è¨ªå•
        off_hours_access = [
            log for log in access_logs
            if self._is_off_hours(log['timestamp'])
        ]
        if len(off_hours_access) > 5:
            analysis['anomalies'].append({
                'type': 'off_hours_access',
                'count': len(off_hours_access),
                'severity': 'medium'
            })
            analysis['risk_score'] += 30
        
        # 2. å¤§é‡è³‡æ–™å°å‡º
        exports = [
            log for log in access_logs
            if log.get('operation') == 'export'
        ]
        if len(exports) > 10:
            analysis['anomalies'].append({
                'type': 'excessive_exports',
                'count': len(exports),
                'severity': 'high'
            })
            analysis['risk_score'] += 50
        
        # 3. è¨ªå•æ•æ„Ÿè³‡æ–™
        sensitive_access = [
            log for log in access_logs
            if log.get('data_classification') == 'sensitive'
        ]
        if len(sensitive_access) > 20:
            analysis['anomalies'].append({
                'type': 'excessive_sensitive_access',
                'count': len(sensitive_access),
                'severity': 'high'
            })
            analysis['risk_score'] += 40
        
        # åˆ¤æ–·æ˜¯å¦ç•°å¸¸
        analysis['is_anomalous'] = analysis['risk_score'] > 50
        
        return analysis
    
    def _is_off_hours(self, timestamp: datetime) -> bool:
        """åˆ¤æ–·æ˜¯å¦éå·¥ä½œæ™‚é–“"""
        hour = timestamp.hour
        weekday = timestamp.weekday()
        
        # é€±æœ«
        if weekday >= 5:
            return True
        
        # éå·¥ä½œæ™‚é–“ï¼ˆé9-18é»ï¼‰
        if hour < 9 or hour >= 18:
            return True
        
        return False
```

#### è§£æ±ºæ–¹æ¡ˆ

**æ–¹æ¡ˆ 1: å¯¦ç¾è³‡æ–™é®ç½©**

```python
class DataMasker:
    """è³‡æ–™é®ç½©å™¨"""
    
    def __init__(self):
        self.masking_rules = {
            'credit_card': self._mask_credit_card,
            'ssn': self._mask_ssn,
            'email': self._mask_email,
            'phone': self._mask_phone,
            'name': self._mask_name
        }
    
    def mask_sensitive_data(
        self,
        data: Dict,
        masking_level: str = 'partial'
    ) -> Dict:
        """é®ç½©æ•æ„Ÿè³‡æ–™"""
        masked_data = data.copy()
        
        for field, value in masked_data.items():
            # åˆ¤æ–·æ¬„ä½é¡å‹
            field_type = self._detect_field_type(field, value)
            
            if field_type in self.masking_rules:
                masker = self.masking_rules[field_type]
                masked_data[field] = masker(value, masking_level)
        
        return masked_data
    
    def _mask_credit_card(self, value: str, level: str) -> str:
        """é®ç½©ä¿¡ç”¨å¡è™Ÿ"""
        if level == 'full':
            return '****-****-****-****'
        else:  # partial
            return f"****-****-****-{value[-4:]}"
    
    def _mask_email(self, value: str, level: str) -> str:
        """é®ç½©é›»å­éƒµä»¶"""
        if level == 'full':
            domain = value.split('@')[1]
            return f"****@{domain}"
        else:  # partial
            local, domain = value.split('@')
            return f"{local[0]}***{local[-1]}@{domain}"
    
    def _mask_phone(self, value: str, level: str) -> str:
        """é®ç½©é›»è©±è™Ÿç¢¼"""
        if level == 'full':
            return '****-***-***'
        else:  # partial
            return f"****-***-{value[-3:]}"
```

---

### å•é¡Œ 3: åŠ å¯†å¯†é‘°ç®¡ç†å•é¡Œ

#### ç—‡ç‹€
- åŠ å¯†æ“ä½œå¤±æ•—
- å¯†é‘°è¼ªæ›éŒ¯èª¤
- è§£å¯†å¤±æ•—

#### è§£æ±ºæ–¹æ¡ˆ

```python
class KeyManagementSystem:
    """å¯†é‘°ç®¡ç†ç³»çµ±"""
    
    def __init__(self, key_store):
        self.key_store = key_store
        self.key_cache = {}
        self.rotation_policy = {
            'encryption_key': 90,  # 90å¤©
            'signing_key': 180,    # 180å¤©
        }
    
    def get_active_key(self, key_type: str) -> bytes:
        """ç²å–ç•¶å‰æ´»å‹•å¯†é‘°"""
        # æª¢æŸ¥å¿«å–
        if key_type in self.key_cache:
            cached_key = self.key_cache[key_type]
            if not self._is_key_expired(cached_key):
                return cached_key['key']
        
        # å¾å¯†é‘°åº«ç²å–
        active_key = self.key_store.get_active_key(key_type)
        
        # æª¢æŸ¥æ˜¯å¦éœ€è¦è¼ªæ›
        if self._should_rotate_key(active_key):
            active_key = self.rotate_key(key_type)
        
        # æ›´æ–°å¿«å–
        self.key_cache[key_type] = {
            'key': active_key['key'],
            'created_at': active_key['created_at'],
            'expires_at': active_key['expires_at']
        }
        
        return active_key['key']
    
    def rotate_key(self, key_type: str) -> Dict:
        """è¼ªæ›å¯†é‘°"""
        # ç”Ÿæˆæ–°å¯†é‘°
        new_key = self._generate_key(key_type)
        
        # ä¿å­˜æ–°å¯†é‘°
        self.key_store.save_key(key_type, new_key, is_active=False)
        
        # æ¨™è¨˜èˆŠå¯†é‘°ç‚ºå·²æ£„ç”¨ï¼ˆä½†ä¿ç•™ç”¨æ–¼è§£å¯†ï¼‰
        old_key = self.key_store.get_active_key(key_type)
        self.key_store.deprecate_key(old_key['id'])
        
        # æ¿€æ´»æ–°å¯†é‘°
        self.key_store.activate_key(new_key['id'])
        
        return new_key
    
    def _should_rotate_key(self, key: Dict) -> bool:
        """åˆ¤æ–·æ˜¯å¦æ‡‰è©²è¼ªæ›å¯†é‘°"""
        key_type = key['type']
        rotation_days = self.rotation_policy.get(key_type, 90)
        
        age_days = (datetime.now() - key['created_at']).days
        
        return age_days >= rotation_days
```

---

## ğŸ“Š ç›£æ§é…ç½®

```yaml
# Prometheus ç›£æ§è¦å‰‡
groups:
  - name: compliance_security
    rules:
      - alert: ComplianceCheckFailureRate
        expr: rate(compliance_check_failures_total[5m]) / rate(compliance_checks_total[5m]) > 0.1
        annotations:
          summary: "åˆè¦æª¢æŸ¥å¤±æ•—ç‡éé«˜"
      
      - alert: SensitiveDataLeakage
        expr: data_leakage_detections_total > 0
        annotations:
          summary: "æª¢æ¸¬åˆ°æ•æ„Ÿè³‡æ–™æ´©æ¼"
      
      - alert: AnomalousAccessDetected
        expr: anomalous_access_events_total > 5
        for: 10m
        annotations:
          summary: "æª¢æ¸¬åˆ°ç•°å¸¸è¨ªå•è¡Œç‚º"
      
      - alert: EncryptionFailure
        expr: rate(encryption_failures_total[5m]) > 10
        annotations:
          summary: "åŠ å¯†æ“ä½œå¤±æ•—ç‡éé«˜"
```

---

**ç›¸é—œç« ç¯€**:
- [7.7 æ•ˆèƒ½å„ªåŒ–ç­–ç•¥](ch7-7-æ•ˆèƒ½å„ªåŒ–ç­–ç•¥.md)
- [7.8 å®‰å…¨è€ƒæ…®](ch7-8-å®‰å…¨è€ƒæ…®.md)
- [â† è¿”å›ç¬¬7ç« é¦–é ](ch7-index.md)

