# ç¬¬7ç« ï¼šè³‡æ–™åˆè¦èˆ‡å®‰å…¨ä¸­å¿ƒ (Data Compliance and Security Center)

## 7.4 æ ¸å¿ƒçµ„ä»¶è©³ç´°å¯¦ç¾

**[â† è¿”å›ç¬¬7ç« é¦–é ](ch7-index.md)**

---

#### 7.4.1 åˆè¦è§„åˆ™å¼•æ“

**æŠ€è¡“å¯¦ç¾ï¼š**
```python
import re
from typing import Dict, List, Optional, Tuple
import logging

class ComplianceRuleEngine:
    """åˆè¦è§„åˆ™å¼•æ“ï¼Œæ‰§è¡Œåˆè¦æ€§æ£€æŸ¥"""
    
    def __init__(
        self,
        rule_repository: ComplianceRuleRepository,
        config: Config
    ):
        self.rule_repository = rule_repository
        self.config = config
        self.logger = logging.getLogger(__name__)
    
    def check_compliance(
        self,
        data_source: DataSource,
        data_content: Optional[bytes] = None
    ) -> ComplianceCheckResult:
        """
        æ£€æŸ¥è³‡æ–™æºçš„åˆè¦æ€§
        
        :param data_source: è³‡æ–™æºç‰©ä»¶
        :param data_content: è³‡æ–™å…§å®¹ï¼ˆå¯é€‰ï¼‰
        :return: åˆè¦æ€§æ£€æŸ¥ç»“æœ
        """
        # 1. ç²å–é€‚ç”¨çš„åˆè¦è§„åˆ™
        applicable_rules = self._get_applicable_rules(data_source)
        
        # 2. æ‰§è¡Œè§„åˆ™æ£€æŸ¥
        results = []
        for rule in applicable_rules:
            result = self._check_rule(rule, data_source, data_content)
            results.append(result)
        
        # 3. ç”Ÿæˆæ±‡æ€»ç»“æœ
        return self._generate_summary(data_source, results)
    
    def _get_applicable_rules(self, data_source: DataSource) -> List[ComplianceRule]:
        """ç²å–é€‚ç”¨æ–¼è³‡æ–™æºçš„åˆè¦è§„åˆ™"""
        # 1. ç²å–è³‡æ–™æºæ‰€åœ¨åœ°åŒº
        region = self._determine_region(data_source)
        
        # 2. ç²å–è³‡æ–™é¡å‹
        data_type = self._determine_data_type(data_source)
        
        # 3. ç²å–é€‚ç”¨è§„åˆ™
        return self.rule_repository.get_rules(
            regions=[region],
            data_types=[data_type],
            active=True
        )
    
    def _determine_region(self, data_source: DataSource) -> str:
        """ç¡®å®šè³‡æ–™æºæ‰€åœ¨åœ°åŒº"""
        # 1. æ£€æŸ¥URLä¸­çš„å›½å®¶ä»£ç 
        url = data_source.url.lower()
        
        # å¸¸è§å›½å®¶ä»£ç é¡¶çº§åŸŸ
        country_tlds = {
            ".uk": "gb",
            ".de": "de",
            ".fr": "fr",
            ".es": "es",
            ".it": "it",
            ".jp": "jp",
            ".cn": "cn",
            ".us": "us",
            ".ca": "ca",
            ".au": "au"
        }
        
        for tld, region in country_tlds.items():
            if tld in url:
                return region
        
        # 2. æ£€æŸ¥IPåœ°ç†ä½ç½®ï¼ˆå¦‚æœå¯¦ç¾ï¼‰
        # ...
        
        # 3. é»˜è®¤ç‚ºå›½é™…
        return "international"
    
    def _determine_data_type(self, data_source: DataSource) -> str:
        """ç¡®å®šè³‡æ–™é¡å‹"""
        # 1. æ£€æŸ¥è³‡æ–™æºé¡å‹
        if data_source.data_type == "user-generated":
            return "personal"
        
        # 2. æ£€æŸ¥å…§å®¹é¡å‹
        content_type = data_source.content_type or ""
        if "json" in content_type or "xml" in content_type:
            return "structured"
        
        # 3. é»˜è®¤é¡å‹
        return "general"
    
    def _check_rule(
        self,
        rule: ComplianceRule,
        data_source: DataSource,
        data_content: Optional[bytes]
    ) -> RuleCheckResult:
        """æ£€æŸ¥å•å€‹è§„åˆ™"""
        # 1. æ£€æŸ¥è§„åˆ™æ˜¯å¦é€‚ç”¨
        if not self._is_rule_applicable(rule, data_source):
            return RuleCheckResult(
                rule_id=rule.id,
                rule_name=rule.name,
                applicable=False,
                passed=None,
                message="è§„åˆ™ä¸é€‚ç”¨"
            )
        
        # 2. æ‰§è¡Œè§„åˆ™æ£€æŸ¥
        try:
            if rule.check_type == "metadata":
                result = self._check_metadata_rule(rule, data_source)
            elif rule.check_type == "content":
                if data_content is None:
                    result = RuleCheckResult(
                        rule_id=rule.id,
                        rule_name=rule.name,
                        applicable=True,
                        passed=False,
                        message="éœ€è¦å…§å®¹æ£€æŸ¥ï¼Œä½†æœªæä¾›å…§å®¹"
                    )
                else:
                    result = self._check_content_rule(rule, data_content)
            else:
                result = RuleCheckResult(
                    rule_id=rule.id,
                    rule_name=rule.name,
                    applicable=True,
                    passed=False,
                    message=f"ä¸æ”¯æ´çš„è§„åˆ™é¡å‹: {rule.check_type}"
                )
            
            return result
            
        except Exception as e:
            return RuleCheckResult(
                rule_id=rule.id,
                rule_name=rule.name,
                applicable=True,
                passed=False,
                message=f"è§„åˆ™æ£€æŸ¥å¤±è´¥: {str(e)}"
            )
    
    def _is_rule_applicable(
        self,
        rule: ComplianceRule,
        data_source: DataSource
    ) -> bool:
        """æ£€æŸ¥è§„åˆ™æ˜¯å¦é€‚ç”¨æ–¼è³‡æ–™æº"""
        # 1. æ£€æŸ¥åœ°åŒºé€‚ç”¨æ€§
        if rule.regions and self._determine_region(data_source) not in rule.regions:
            return False
        
        # 2. æ£€æŸ¥è³‡æ–™é¡å‹é€‚ç”¨æ€§
        if rule.data_types and self._determine_data_type(data_source) not in rule.data_types:
            return False
        
        # 3. æ£€æŸ¥è³‡æ–™æºåˆ†é¡é€‚ç”¨æ€§
        if rule.categories and data_source.category not in rule.categories:
            return False
        
        return True
    
    def _check_metadata_rule(
        self,
        rule: ComplianceRule,
        data_source: DataSource
    ) -> RuleCheckResult:
        """æ£€æŸ¥å…ƒè³‡æ–™è§„åˆ™"""
        # 1. æå–æ£€æŸ¥åƒæ•¸
        field = rule.parameters.get("field")
        operator = rule.parameters.get("operator")
        value = rule.parameters.get("value")
        
        if not field or not operator:
            return RuleCheckResult(
                rule_id=rule.id,
                rule_name=rule.name,
                applicable=True,
                passed=False,
                message="è§„åˆ™é…ç½®ä¸å®Œæ•´"
            )
        
        # 2. ç²å–å­—æ®µå€¼
        field_value = self._get_metadata_field(data_source, field)
        if field_value is None:
            return RuleCheckResult(
                rule_id=rule.id,
                rule_name=rule.name,
                applicable=True,
                passed=False,
                message=f"å…ƒè³‡æ–™å­—æ®µ '{field}' ä¸å­˜åœ¨"
            )
        
        # 3. æ‰§è¡Œæ£€æŸ¥
        passed = self._evaluate_condition(field_value, operator, value)
        
        # 4. ç”Ÿæˆç»“æœ
        return RuleCheckResult(
            rule_id=rule.id,
            rule_name=rule.name,
            applicable=True,
            passed=passed,
            message=self._generate_message(rule, field_value, passed)
        )
    
    def _get_metadata_field(
        self,
        data_source: DataSource,
        field: str
    ) -> Optional[Any]:
        """ç²å–å…ƒè³‡æ–™å­—æ®µå€¼"""
        if field == "url":
            return data_source.url
        elif field == "category":
            return data_source.category
        elif field == "data_type":
            return data_source.data_type
        elif field == "content_type":
            return data_source.content_type
        elif field.startswith("metadata."):
            key = field.split(".", 1)[1]
            return data_source.metadata.get(key)
        
        return None
    
    def _evaluate_condition(
        self,
        actual: Any,
        operator: str,
        expected: Any
    ) -> bool:
        """è©•ä¼°æ¢ä»¶è¡¨è¾¾å¼"""
        if operator == "eq":
            return actual == expected
        elif operator == "neq":
            return actual != expected
        elif operator == "contains":
            return expected in str(actual)
        elif operator == "regex":
            return bool(re.search(expected, str(actual)))
        elif operator == "in":
            return actual in expected.split(",")
        elif operator == "not_in":
            return actual not in expected.split(",")
        
        return False
    
    def _generate_message(
        self,
        rule: ComplianceRule,
        field_value: Any,
        passed: bool
    ) -> str:
        """ç”Ÿæˆæ£€æŸ¥ç»“æœæ¶ˆæ¯"""
        if passed:
            return f"è§„åˆ™é€šé: {rule.description}"
        
        return f"è§„åˆ™å¤±è´¥: {rule.description} (æª¢æ¸¬åˆ°: {field_value})"
    
    def _check_content_rule(
        self,
        rule: ComplianceRule,
        data_content: bytes
    ) -> RuleCheckResult:
        """æ£€æŸ¥å…§å®¹è§„åˆ™"""
        # 1. æ£€æŸ¥å…§å®¹é¡å‹
        if rule.content_type not in ["text", "json", "xml", "html"]:
            return RuleCheckResult(
                rule_id=rule.id,
                rule_name=rule.name,
                applicable=True,
                passed=False,
                message=f"ä¸æ”¯æ´çš„å…§å®¹é¡å‹: {rule.content_type}"
            )
        
        # 2. è§£æå…§å®¹
        try:
            content = self._parse_content(data_content, rule.content_type)
        except Exception as e:
            return RuleCheckResult(
                rule_id=rule.id,
                rule_name=rule.name,
                applicable=True,
                passed=False,
                message=f"å…§å®¹è§£æå¤±è´¥: {str(e)}"
            )
        
        # 3. æ‰§è¡Œæ£€æŸ¥
        findings = []
        for pattern in rule.patterns:
            matches = self._find_pattern_matches(pattern, content)
            if matches:
                findings.extend(matches)
        
        # 4. ç”Ÿæˆç»“æœ
        passed = len(findings) == 0
        message = self._generate_content_message(rule, findings)
        
        return RuleCheckResult(
            rule_id=rule.id,
            rule_name=rule.name,
            applicable=True,
            passed=passed,
            message=message,
            details={"findings": findings}
        )
    
    def _parse_content(
        self,
        content: bytes,
        content_type: str
    ) -> Any:
        """è§£æå…§å®¹"""
        # å°è¯•è§£ç ç‚ºUTF-8
        try:
            text = content.decode('utf-8')
        except UnicodeDecodeError:
            text = content.decode('latin-1')
        
        # æ ¹æ“šå…§å®¹é¡å‹è¿›ä¸€æ­¥è™•ç†
        if content_type == "json":
            try:
                return json.loads(text)
            except json.JSONDecodeError:
                return text
        elif content_type in ["xml", "html"]:
            # è¿”å›åŸå§‹æ–‡æœ¬ï¼Œç”±æ¨¡å¼åŒ¹é…è™•ç†
            return text
        else:
            return text
    
    def _find_pattern_matches(
        self,
        pattern: CompliancePattern,
        content: Any
    ) -> List[Dict]:
        """æŸ¥æ‰¾æ¨¡å¼åŒ¹é…"""
        matches = []
        
        if isinstance(content, str):
            # åœ¨æ–‡æœ¬ä¸­æœå°‹
            for match in re.finditer(pattern.regex, content):
                matches.append({
                    "pattern_id": pattern.id,
                    "start": match.start(),
                    "end": match.end(),
                    "value": match.group(0),
                    "context": self._get_context(content, match.start(), match.end())
                })
        
        elif isinstance(content, dict):
            # é€’å½’æœå°‹å­—å…¸
            self._search_dict(content, pattern, "", matches)
        
        elif isinstance(content, list):
            # é€’å½’æœå°‹åˆ—è¡¨
            self._search_list(content, pattern, "", matches)
        
        return matches
    
    def _get_context(
        self,
        text: str,
        start: int,
        end: int,
        context_size: int = 20
    ) -> str:
        """ç²å–åŒ¹é…ä¸Šä¸‹æ–‡"""
        context_start = max(0, start - context_size)
        context_end = min(len(text), end + context_size)
        return text[context_start:context_start] + "[...]" + text[end:context_end]
    
    def _search_dict(
        self,
        obj: Dict,
        pattern: CompliancePattern,
        path: str,
        matches: List[Dict]
    ):
        """åœ¨å­—å…¸ä¸­æœå°‹æ¨¡å¼"""
        for key, value in obj.items():
            current_path = f"{path}.{key}" if path else key
            
            # æ£€æŸ¥éµ
            if re.search(pattern.regex, key):
                matches.append({
                    "pattern_id": pattern.id,
                    "path": current_path,
                    "value": key,
                    "type": "key"
                })
            
            # æ£€æŸ¥å€¼
            if isinstance(value, (str, int, float)):
                value_str = str(value)
                for match in re.finditer(pattern.regex, value_str):
                    matches.append({
                        "pattern_id": pattern.id,
                        "path": current_path,
                        "value": value_str[match.start():match.end()],
                        "start": match.start(),
                        "end": match.end(),
                        "type": "value"
                    })
            
            # é€’å½’æœå°‹
            elif isinstance(value, dict):
                self._search_dict(value, pattern, current_path, matches)
            elif isinstance(value, list):
                self._search_list(value, pattern, current_path, matches)
    
    def _search_list(
        self,
        obj: List,
        pattern: CompliancePattern,
        path: str,
        matches: List[Dict]
    ):
        """åœ¨åˆ—è¡¨ä¸­æœå°‹æ¨¡å¼"""
        for i, item in enumerate(obj):
            current_path = f"{path}[{i}]"
            
            # æ£€æŸ¥å€¼
            if isinstance(item, (str, int, float)):
                value_str = str(item)
                for match in re.finditer(pattern.regex, value_str):
                    matches.append({
                        "pattern_id": pattern.id,
                        "path": current_path,
                        "value": value_str[match.start():match.end()],
                        "start": match.start(),
                        "end": match.end(),
                        "type": "value"
                    })
            
            # é€’å½’æœå°‹
            elif isinstance(item, dict):
                self._search_dict(item, pattern, current_path, matches)
            elif isinstance(item, list):
                self._search_list(item, pattern, current_path, matches)
    
    def _generate_content_message(
        self,
        rule: ComplianceRule,
        findings: List[Dict]
    ) -> str:
        """ç”Ÿæˆå…§å®¹æ£€æŸ¥æ¶ˆæ¯"""
        if not findings:
            return f"è§„åˆ™é€šé: {rule.description}"
        
        return f"è§„åˆ™å¤±è´¥: {rule.description} (æª¢æ¸¬åˆ° {len(findings)} å¤„æ•æ„Ÿè³‡æ–™)"
    
    def _generate_summary(
        self,
        data_source: DataSource,
        results: List[RuleCheckResult]
    ) -> ComplianceCheckResult:
        """ç”Ÿæˆåˆè¦æ€§æ£€æŸ¥æ±‡æ€»"""
        # ç»Ÿè®¡ç»“æœ
        total = len(results)
        passed = sum(1 for r in results if r.passed)
        failed = sum(1 for r in results if not r.passed and r.applicable)
        not_applicable = sum(1 for r in results if not r.applicable)
        
        # ç”Ÿæˆç‹€æ…‹
        if failed == 0:
            status = "compliant"
        elif failed <= self.config.warning_threshold:
            status = "warning"
        else:
            status = "non_compliant"
        
        # ç”Ÿæˆé—œéµé—®é¢˜
        critical_issues = [
            r for r in results 
            if not r.passed and r.applicable and r.rule_severity == "critical"
        ]
        
        # ç”Ÿæˆå»ºè­°
        suggestions = self._generate_suggestions(results)
        
        return ComplianceCheckResult(
            data_source_id=data_source.id,
            project_id=data_source.project_id,
            status=status,
            total_rules=total,
            passed_rules=passed,
            failed_rules=failed,
            not_applicable_rules=not_applicable,
            critical_issues=len(critical_issues),
            results=results,
            suggestions=suggestions,
            timestamp=datetime.utcnow()
        )
    
    def _generate_suggestions(self, results: List[RuleCheckResult]) -> List[str]:
        """ç”Ÿæˆåˆè¦æ€§å»ºè­°"""
        suggestions = []
        
        # 1. é’ˆå°å¤±è´¥çš„é—œéµè§„åˆ™
        critical_failures = [
            r for r in results 
            if not r.passed and r.applicable and r.rule_severity == "critical"
        ]
        for result in critical_failures[:3]:  # åªå–å‰3å€‹
            suggestions.append(f"å¿…é ˆè§£å†³: {result.rule_name} - {result.message}")
        
        # 2. é’ˆå°è­¦å‘Šçº§åˆ«çš„è§„åˆ™
        warning_failures = [
            r for r in results 
            if not r.passed and r.applicable and r.rule_severity == "warning"
        ]
        if warning_failures:
            suggestions.append(f"å»ºè­°æ”¹è¿›: æª¢æ¸¬åˆ° {len(warning_failures)} å€‹å¯å„ªåŒ–çš„åˆè¦æ€§é—®é¢˜")
        
        # 3. ä¸€èˆ¬å»ºè­°
        if not suggestions:
            suggestions.append("è³‡æ–™æºç¬¦åˆæ‰€æœ‰é—œéµåˆè¦æ€§è¦æ±‚")
        
        return suggestions

class ComplianceRuleRepository:
    """åˆè¦è§„åˆ™ä»“åº«"""
    
    def __init__(self, db: Database):
        self.db = db
        self.logger = logging.getLogger(__name__)
    
    def get_rules(
        self,
        regions: List[str] = None,
        data_types: List[str] = None,
        categories: List[str] = None,
        active: bool = True
    ) -> List[ComplianceRule]:
        """ç²å–åˆè¦è§„åˆ™"""
        # æ§‹å»ºæŸ¥è©¢
        conditions = []
        params = {"active": active}
        
        if regions:
            conditions.append("regions && %(regions)s::varchar[]")
            params["regions"] = regions
        if data_types:
            conditions.append("data_types && %(data_types)s::varchar[]")
            params["data_types"] = data_types
        if categories:
            conditions.append("categories && %(categories)s::varchar[]")
            params["categories"] = categories
        
        where_clause = "WHERE active = %(active)s"
        if conditions:
            where_clause += " AND " + " AND ".join(conditions)
        
        sql = f"""
        SELECT * FROM compliance_rules 
        {where_clause}
        ORDER BY severity DESC, priority
        """
        
        rows = self.db.fetchall(sql, params)
        return [self._row_to_rule(row) for row in rows]
    
    def get_rule(self, rule_id: str) -> Optional[ComplianceRule]:
        """ç²å–å•å€‹åˆè¦è§„åˆ™"""
        sql = "SELECT * FROM compliance_rules WHERE id = %(id)s"
        row = self.db.fetchone(sql, {"id": rule_id})
        return self._row_to_rule(row) if row else None
    
    def _row_to_rule(self, row: Dict) -> ComplianceRule:
        """å°‡è³‡æ–™åº«è¡Œè½¬æ¢ç‚ºComplianceRuleç‰©ä»¶"""
        return ComplianceRule(
            id=row["id"],
            name=row["name"],
            description=row["description"],
            regulation=row["regulation"],
            severity=row["severity"],
            check_type=row["check_type"],
            content_type=row["content_type"],
            regions=json.loads(row["regions"]) if row["regions"] else [],
            data_types=json.loads(row["data_types"]) if row["data_types"] else [],
            categories=json.loads(row["categories"]) if row["categories"] else [],
            parameters=json.loads(row["parameters"]) if row["parameters"] else {},
            patterns=self._decode_patterns(row["patterns"]),
            priority=row["priority"],
            active=row["active"],
            created_at=row["created_at"],
            updated_at=row["updated_at"]
        )
    
    def _decode_patterns(self, json_data: str) -> List[CompliancePattern]:
        """è§£ç æ¨¡å¼å®šç¾©"""
        if not json_data:
            return []
        
        patterns_data = json.loads(json_data)
        return [
            CompliancePattern(
                id=p["id"],
                name=p["name"],
                description=p.get("description", ""),
                regex=p["regex"],
                data_category=p["data_category"],
                severity=p["severity"]
            ) for p in patterns_data
        ]

# è¼”åŠ©ç±»å®šç¾©
class ComplianceRule:
    """åˆè¦è§„åˆ™"""
    def __init__(
        self,
        id: str,
        name: str,
        description: str,
        regulation: str,
        severity: str,
        check_type: str,
        content_type: str,
        regions: List[str],
        data_types: List[str],
        categories: List[str],
        parameters: Dict,
        patterns: List,
        priority: int,
        active: bool,
        created_at: datetime,
        updated_at: datetime
    ):
        self.id = id
        self.name = name
        self.description = description
        self.regulation = regulation
        self.severity = severity
        self.check_type = check_type
        self.content_type = content_type
        self.regions = regions
        self.data_types = data_types
        self.categories = categories
        self.parameters = parameters
        self.patterns = patterns
        self.priority = priority
        self.active = active
        self.created_at = created_at
        self.updated_at = updated_at

class CompliancePattern:
    """åˆè¦æ¨¡å¼"""
    def __init__(
        self,
        id: str,
        name: str,
        description: str,
        regex: str,
        data_category: str,
        severity: str
    ):
        self.id = id
        self.name = name
        self.description = description
        self.regex = regex
        self.data_category = data_category
        self.severity = severity

class RuleCheckResult:
    """è§„åˆ™æ£€æŸ¥ç»“æœ"""
    def __init__(
        self,
        rule_id: str,
        rule_name: str,
        applicable: bool,
        passed: Optional[bool],
        message: str,
        details: Optional[Dict] = None
    ):
        self.rule_id = rule_id
        self.rule_name = rule_name
        self.applicable = applicable
        self.passed = passed
        self.message = message
        self.details = details or {}
        self.rule_severity = "warning"  # å¯ä»¥å¾è§„åˆ™ä¸­ç²å–

class ComplianceCheckResult:
    """åˆè¦æ€§æ£€æŸ¥ç»“æœ"""
    def __init__(
        self,
        data_source_id: str,
        project_id: str,
        status: str,
        total_rules: int,
        passed_rules: int,
        failed_rules: int,
        not_applicable_rules: int,
        critical_issues: int,
        results: List[RuleCheckResult],
        suggestions: List[str],
        timestamp: datetime
    ):
        self.data_source_id = data_source_id
        self.project_id = project_id
        self.status = status
        self.total_rules = total_rules
        self.passed_rules = passed_rules
        self.failed_rules = failed_rules
        self.not_applicable_rules = not_applicable_rules
        self.critical_issues = critical_issues
        self.results = results
        self.suggestions = suggestions
        self.timestamp = timestamp
```

#### 7.4.2 æ•æ„Ÿè³‡æ–™æª¢æ¸¬å™¨

**æŠ€è¡“å¯¦ç¾ï¼š**
```python
import re
import json
from typing import Dict, List, Optional, Tuple
import logging
import hashlib

class SensitiveDataDetector:
    """æ•æ„Ÿè³‡æ–™æª¢æ¸¬å™¨ï¼Œæª¢æ¸¬è³‡æ–™ä¸­çš„æ•æ„Ÿè³‡è¨Š"""
    
    def __init__(
        self,
        pattern_repository: PatternRepository,
        config: Config
    ):
        self.pattern_repository = pattern_repository
        self.config = config
        self.logger = logging.getLogger(__name__)
    
    def detect(
        self,
        data: Any,
        context: Optional[Dict] = None
    ) -> SensitiveDataDetectionResult:
        """
        æª¢æ¸¬è³‡æ–™ä¸­çš„æ•æ„Ÿè³‡è¨Š
        
        :param data: è¦æª¢æ¸¬çš„è³‡æ–™
        :param context: ä¸Šä¸‹æ–‡è³‡è¨Š
        :return: æª¢æ¸¬ç»“æœ
        """
        # 1. ç²å–æ•æ„Ÿè³‡æ–™æ¨¡å¼
        patterns = self.pattern_repository.get_patterns(
            categories=context.get("categories") if context else None,
            regions=context.get("regions") if context else None
        )
        
        # 2. æ‰§è¡Œæª¢æ¸¬
        findings = self._scan_data(data, patterns)
        
        # 3. ç”Ÿæˆç»“æœ
        return SensitiveDataDetectionResult(
            data_hash=self._calculate_data_hash(data),
            total_patterns=len(patterns),
            findings=findings,
            context=context or {},
            timestamp=datetime.utcnow()
        )
    
    def _calculate_data_hash(self, data: Any) -> str:
        """è®¡ç®—è³‡æ–™å“ˆå¸Œ"""
        # ç®€å•å¯¦ç¾ï¼šè½¬æ¢ç‚ºJSONä¸¦è®¡ç®—å“ˆå¸Œ
        try:
            data_str = json.dumps(data, sort_keys=True)
            return hashlib.sha256(data_str.encode('utf-8')).hexdigest()
        except:
            return "unknown"
    
    def _scan_data(
        self,
        data: Any,
        patterns: List[DataPattern]
    ) -> List[DataFinding]:
        """æ‰«æè³‡æ–™ä¸­çš„æ•æ„Ÿè³‡è¨Š"""
        findings = []
        
        if isinstance(data, str):
            # æ‰«æå­—ç¬¦ä¸²
            for pattern in patterns:
                for match in re.finditer(pattern.regex, data):
                    findings.append(DataFinding(
                        pattern_id=pattern.id,
                        pattern_name=pattern.name,
                        data_category=pattern.data_category,
                        start=match.start(),
                        end=match.end(),
                        value=match.group(0),
                        context=self._get_context(data, match.start(), match.end())
                    ))
        
        elif isinstance(data, dict):
            # é€’å½’æ‰«æå­—å…¸
            for key, value in data.items():
                # æ£€æŸ¥éµ
                for pattern in patterns:
                    if re.search(pattern.regex, key):
                        findings.append(DataFinding(
                            pattern_id=pattern.id,
                            pattern_name=pattern.name,
                            data_category=pattern.data_category,
                            path=key,
                            value=key,
                            type="key",
                            context=f"Key: {key}"
                        ))
                
                # æ£€æŸ¥å€¼
                sub_findings = self._scan_data(value, patterns)
                for finding in sub_findings:
                    finding.path = f"{key}.{finding.path}" if finding.path else key
                    findings.append(finding)
        
        elif isinstance(data, list):
            # é€’å½’æ‰«æåˆ—è¡¨
            for i, item in enumerate(data):
                sub_findings = self._scan_data(item, patterns)
                for finding in sub_findings:
                    finding.path = f"[{i}]{finding.path}"
                    findings.append(finding)
        
        return findings
    
    def _get_context(
        self,
        text: str,
        start: int,
        end: int,
        context_size: int = 20
    ) -> str:
        """ç²å–åŒ¹é…ä¸Šä¸‹æ–‡"""
        context_start = max(0, start - context_size)
        context_end = min(len(text), end + context_size)
        return text[context_start:start] + "[...]" + text[end:context_end]

class PatternRepository:
    """æ•æ„Ÿè³‡æ–™æ¨¡å¼ä»“åº«"""
    
    def __init__(self, db: Database):
        self.db = db
        self.logger = logging.getLogger(__name__)
    
    def get_patterns(
        self,
        categories: List[str] = None,
        regions: List[str] = None
    ) -> List[DataPattern]:
        """ç²å–æ•æ„Ÿè³‡æ–™æ¨¡å¼"""
        # æ§‹å»ºæŸ¥è©¢
        conditions = []
        params = {}
        
        if categories:
            conditions.append("categories && %(categories)s::varchar[]")
            params["categories"] = categories
        if regions:
            conditions.append("regions && %(regions)s::varchar[]")
            params["regions"] = regions
        
        where_clause = "WHERE active = true"
        if conditions:
            where_clause += " AND " + " AND ".join(conditions)
        
        sql = f"""
        SELECT * FROM sensitive_data_patterns 
        {where_clause}
        ORDER BY severity DESC, priority
        """
        
        rows = self.db.fetchall(sql, params)
        return [self._row_to_pattern(row) for row in rows]
    
    def get_pattern(self, pattern_id: str) -> Optional[DataPattern]:
        """ç²å–å•å€‹æ•æ„Ÿè³‡æ–™æ¨¡å¼"""
        sql = "SELECT * FROM sensitive_data_patterns WHERE id = %(id)s"
        row = self.db.fetchone(sql, {"id": pattern_id})
        return self._row_to_pattern(row) if row else None
    
    def _row_to_pattern(self, row: Dict) -> DataPattern:
        """å°‡è³‡æ–™åº«è¡Œè½¬æ¢ç‚ºDataPatternç‰©ä»¶"""
        return DataPattern(
            id=row["id"],
            name=row["name"],
            description=row["description"],
            regex=row["regex"],
            data_category=row["data_category"],
            severity=row["severity"],
            categories=json.loads(row["categories"]) if row["categories"] else [],
            regions=json.loads(row["regions"]) if row["regions"] else [],
            validation_rules=json.loads(row["validation_rules"]) if row["validation_rules"] else [],
            redaction_template=row["redaction_template"],
            priority=row["priority"],
            active=row["active"],
            created_at=row["created_at"],
            updated_at=row["updated_at"]
        )

# è¼”åŠ©ç±»å®šç¾©
class DataPattern:
    """æ•æ„Ÿè³‡æ–™æ¨¡å¼"""
    def __init__(
        self,
        id: str,
        name: str,
        description: str,
        regex: str,
        data_category: str,
        severity: str,
        categories: List[str],
        regions: List[str],
        validation_rules: List[Dict],
        redaction_template: str,
        priority: int,
        active: bool,
        created_at: datetime,
        updated_at: datetime
    ):
        self.id = id
        self.name = name
        self.description = description
        self.regex = regex
        self.data_category = data_category
        self.severity = severity
        self.categories = categories
        self.regions = regions
        self.validation_rules = validation_rules
        self.redaction_template = redaction_template
        self.priority = priority
        self.active = active
        self.created_at = created_at
        self.updated_at = updated_at

class DataFinding:
    """è³‡æ–™ç™¼ç¾"""
    def __init__(
        self,
        pattern_id: str,
        pattern_name: str,
        data_category: str,
        start: Optional[int] = None,
        end: Optional[int] = None,
        value: str = "",
        context: str = "",
        path: str = "",
        type: str = "value"
    ):
        self.pattern_id = pattern_id
        self.pattern_name = pattern_name
        self.data_category = data_category
        self.start = start
        self.end = end
        self.value = value
        self.context = context
        self.path = path
        self.type = type

class SensitiveDataDetectionResult:
    """æ•æ„Ÿè³‡æ–™æª¢æ¸¬ç»“æœ"""
    def __init__(
        self,
        data_hash: str,
        total_patterns: int,
        findings: List[DataFinding],
        context: Dict,
        timestamp: datetime
    ):
        self.data_hash = data_hash
        self.total_patterns = total_patterns
        self.findings = findings
        self.context = context
        self.timestamp = timestamp
        self.severity = self._calculate_severity()
    
    def _calculate_severity(self) -> str:
        """è®¡ç®—æª¢æ¸¬ç»“æœä¸¥é‡ç¨‹åº¦"""
        if not self.findings:
            return "none"
        
        # æ£€æŸ¥æ˜¯å¦æœ‰é—œéµç™¼ç¾
        has_critical = any(f.data_category == "critical" for f in self.findings)
        if has_critical:
            return "critical"
        
        # æ£€æŸ¥ç™¼ç¾æ•¸é‡
        if len(self.findings) > 5:
            return "high"
        elif len(self.findings) > 2:
            return "medium"
        
        return "low"
```

---

## ğŸ“‘ ç›¸é—œç« ç¯€

| å‰åº | ç•¶å‰ | å¾ŒçºŒ |
|-----|------|------|
| [7.3 æŠ€è¡“æ¶æ§‹](ch7-3-æŠ€è¡“æ¶æ§‹.md) | **7.4 æ ¸å¿ƒçµ„ä»¶è©³ç´°å¯¦ç¾** | [7.5 è³‡æ–™æ¨¡å‹è©³ç´°å®šç¾©](ch7-5-è³‡æ–™æ¨¡å‹è©³ç´°å®šç¾©.md) |

**å¿«é€Ÿéˆæ¥ï¼š**
- [7.3 æŠ€è¡“æ¶æ§‹](ch7-3-æŠ€è¡“æ¶æ§‹.md)
- [7.5 è³‡æ–™æ¨¡å‹è©³ç´°å®šç¾©](ch7-5-è³‡æ–™æ¨¡å‹è©³ç´°å®šç¾©.md)
- [â† è¿”å›ç¬¬7ç« é¦–é ](ch7-index.md)
