# 第6章：AI輔助開發系統 (AI-Assisted Development System)

## 6.11 故障排查指南

**[← 返回第6章首頁](ch6-index.md)**

---

## 🐛 常見問題與解決方案

### 問題 1: LLM API 調用失敗

#### 症狀
- API 請求超時
- 速率限制錯誤
- 回應質量差

#### 診斷工具

```python
class LLMDiagnostics:
    """LLM 診斷工具"""
    
    def diagnose_api_call(self, provider: str, model: str) -> Dict:
        """診斷 API 調用"""
        diagnostics = {
            'provider': provider,
            'model': model,
            'issues': [],
            'metrics': {},
            'suggestions': []
        }
        
        # 測試連接
        connectivity = self._test_connectivity(provider)
        diagnostics['metrics']['connectivity'] = connectivity
        
        if not connectivity['success']:
            diagnostics['issues'].append("無法連接到 API 端點")
            diagnostics['suggestions'].append("檢查網路連接和 API 密鑰")
        
        # 測試速率限制
        rate_limit = self._test_rate_limit(provider, model)
        diagnostics['metrics']['rate_limit'] = rate_limit
        
        if rate_limit['remaining'] < rate_limit['limit'] * 0.1:
            diagnostics['issues'].append(f"速率限制即將用盡: {rate_limit['remaining']}/{rate_limit['limit']}")
            diagnostics['suggestions'].append("考慮升級配額或使用速率限制器")
        
        # 測試響應時間
        latency = self._test_latency(provider, model)
        diagnostics['metrics']['latency'] = latency
        
        if latency > 10:  # 秒
            diagnostics['issues'].append(f"響應時間過長: {latency}秒")
            diagnostics['suggestions'].append("考慮使用更小的模型或啟用流式響應")
        
        return diagnostics
    
    def _test_connectivity(self, provider: str) -> Dict:
        """測試連接"""
        try:
            response = requests.get(
                f"https://api.{provider}.com/health",
                timeout=5
            )
            return {
                'success': response.status_code == 200,
                'status_code': response.status_code
            }
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }
```

#### 解決方案

**方案 1: 實現智能重試機制**

```python
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

class RobustLLMClient:
    """健壯的 LLM 客戶端"""
    
    def __init__(self, api_key: str, base_url: str):
        self.api_key = api_key
        self.base_url = base_url
        self.session = self._create_session()
    
    def _create_session(self):
        """創建 HTTP Session"""
        session = requests.Session()
        session.headers.update({
            'Authorization': f'Bearer {self.api_key}',
            'Content-Type': 'application/json'
        })
        
        # 配置重試
        retry_strategy = Retry(
            total=3,
            backoff_factor=1,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["POST"]
        )
        
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        
        return session
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=4, max=10),
        retry=retry_if_exception_type((requests.exceptions.Timeout, requests.exceptions.RequestException))
    )
    def chat_completion(
        self,
        messages: List[Dict],
        model: str = "gpt-3.5-turbo",
        temperature: float = 0.7,
        max_tokens: int = 1000,
        timeout: int = 30
    ) -> Dict:
        """聊天補全（帶重試）"""
        try:
            response = self.session.post(
                f"{self.base_url}/chat/completions",
                json={
                    "model": model,
                    "messages": messages,
                    "temperature": temperature,
                    "max_tokens": max_tokens
                },
                timeout=timeout
            )
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.HTTPError as e:
            if e.response.status_code == 429:
                # 速率限制錯誤
                retry_after = int(e.response.headers.get('Retry-After', 60))
                self.logger.warning(f"速率限制，等待 {retry_after} 秒")
                time.sleep(retry_after)
                raise  # 重試
            else:
                raise
```

**方案 2: 實現回退策略**

```python
class MultiProviderLLMClient:
    """多提供商 LLM 客戶端"""
    
    def __init__(self):
        self.providers = [
            {'name': 'openai', 'client': OpenAIClient(), 'priority': 1},
            {'name': 'anthropic', 'client': AnthropicClient(), 'priority': 2},
            {'name': 'local', 'client': LocalLLMClient(), 'priority': 3}
        ]
        
        # 按優先級排序
        self.providers.sort(key=lambda x: x['priority'])
    
    def complete(self, prompt: str, **kwargs) -> str:
        """完成請求（自動回退）"""
        last_error = None
        
        for provider in self.providers:
            try:
                self.logger.info(f"嘗試使用 {provider['name']}")
                
                result = provider['client'].complete(prompt, **kwargs)
                
                # 驗證結果質量
                if self._validate_response(result):
                    return result
                else:
                    self.logger.warning(f"{provider['name']} 返回低質量響應")
                    continue
                    
            except Exception as e:
                self.logger.error(f"{provider['name']} 失敗: {str(e)}")
                last_error = e
                continue
        
        # 所有提供商都失敗
        raise Exception(f"所有 LLM 提供商都失敗: {last_error}")
    
    def _validate_response(self, response: str) -> bool:
        """驗證響應質量"""
        if not response or len(response) < 10:
            return False
        
        # 檢查是否包含錯誤訊息
        error_patterns = ['error', 'failed', 'unable to']
        if any(pattern in response.lower() for pattern in error_patterns):
            return False
        
        return True
```

---

### 問題 2: 代碼生成質量差

#### 症狀
- 生成的代碼無法運行
- 邏輯錯誤
- 不符合規範

#### 解決方案

```python
class CodeQualityValidator:
    """代碼質量驗證器"""
    
    def __init__(self):
        self.validators = [
            self._validate_syntax,
            self._validate_imports,
            self._validate_style,
            self._validate_security
        ]
    
    def validate(self, code: str, language: str) -> Dict:
        """驗證代碼質量"""
        results = {
            'valid': True,
            'issues': [],
            'suggestions': [],
            'score': 100
        }
        
        for validator in self.validators:
            try:
                validator_result = validator(code, language)
                
                if not validator_result['valid']:
                    results['valid'] = False
                    results['issues'].extend(validator_result['issues'])
                    results['suggestions'].extend(validator_result['suggestions'])
                    results['score'] -= validator_result.get('penalty', 10)
                    
            except Exception as e:
                self.logger.error(f"驗證器錯誤: {str(e)}")
        
        return results
    
    def _validate_syntax(self, code: str, language: str) -> Dict:
        """驗證語法"""
        if language == 'python':
            try:
                compile(code, '<string>', 'exec')
                return {'valid': True}
            except SyntaxError as e:
                return {
                    'valid': False,
                    'issues': [f"語法錯誤: {str(e)}"],
                    'suggestions': ["檢查代碼語法"],
                    'penalty': 30
                }
        
        return {'valid': True}
    
    def _validate_style(self, code: str, language: str) -> Dict:
        """驗證代碼風格"""
        if language == 'python':
            import pycodestyle
            
            checker = pycodestyle.Checker('<string>', lines=code.splitlines())
            checker.check_all()
            
            if checker.results:
                return {
                    'valid': False,
                    'issues': [f"風格問題: {r}" for r in checker.results[:5]],
                    'suggestions': ["遵循 PEP 8 規範"],
                    'penalty': 5
                }
        
        return {'valid': True}
    
    def _validate_security(self, code: str, language: str) -> Dict:
        """驗證安全性"""
        # 檢查危險函數
        dangerous_patterns = [
            'eval(',
            'exec(',
            'os.system(',
            'subprocess.call(',
            '__import__'
        ]
        
        issues = []
        for pattern in dangerous_patterns:
            if pattern in code:
                issues.append(f"發現潛在危險函數: {pattern}")
        
        if issues:
            return {
                'valid': False,
                'issues': issues,
                'suggestions': ["避免使用危險函數", "使用更安全的替代方案"],
                'penalty': 20
            }
        
        return {'valid': True}

class ImprovedCodeGenerator:
    """改進的代碼生成器"""
    
    def __init__(self, llm_client, validator):
        self.llm = llm_client
        self.validator = validator
        self.max_iterations = 3
    
    def generate(self, prompt: str, language: str = 'python') -> str:
        """生成高質量代碼"""
        for iteration in range(self.max_iterations):
            # 生成代碼
            code = self._generate_code(prompt, language, iteration)
            
            # 驗證質量
            validation = self.validator.validate(code, language)
            
            if validation['valid'] or validation['score'] >= 80:
                return code
            
            # 根據反饋改進提示
            prompt = self._improve_prompt(
                prompt,
                validation['issues'],
                validation['suggestions']
            )
        
        # 返回最佳嘗試
        return code
    
    def _improve_prompt(
        self,
        original_prompt: str,
        issues: List[str],
        suggestions: List[str]
    ) -> str:
        """改進提示"""
        feedback = "\n".join([
            "之前生成的代碼存在以下問題:",
            *[f"- {issue}" for issue in issues],
            "\n請根據以下建議改進:",
            *[f"- {suggestion}" for suggestion in suggestions]
        ])
        
        return f"{original_prompt}\n\n{feedback}"
```

---

## 📊 效能監控

```yaml
# Prometheus 監控
groups:
  - name: ai_assisted_dev
    rules:
      - alert: HighLLMErrorRate
        expr: rate(llm_api_errors_total[5m]) / rate(llm_api_requests_total[5m]) > 0.1
        annotations:
          summary: "LLM API 錯誤率過高"
      
      - alert: SlowLLMResponse
        expr: histogram_quantile(0.95, rate(llm_response_duration_seconds_bucket[5m])) > 30
        annotations:
          summary: "LLM 響應時間過長（P95 > 30秒）"
      
      - alert: LowCodeQuality
        expr: avg(code_quality_score) < 70
        for: 10m
        annotations:
          summary: "代碼生成質量下降"
```

---

**相關章節**:
- [6.7 效能優化策略](ch6-7-效能優化策略.md)
- [← 返回第6章首頁](ch6-index.md)

