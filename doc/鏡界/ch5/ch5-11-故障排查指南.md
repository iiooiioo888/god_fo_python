# 第5章：自動化媒體處理管道 (Automated Media Processing Pipeline)

## 5.11 故障排查指南

**[← 返回第5章首頁](ch5-index.md)**

---

## 🐛 常見問題與解決方案

### 問題 1: 影片處理失敗

#### 症狀
- FFmpeg 處理錯誤
- 轉碼任務超時
- 輸出文件損壞

#### 診斷工具

```python
class MediaProcessingDiagnostics:
    """媒體處理診斷工具"""
    
    def analyze_video_file(self, file_path: str) -> Dict:
        """分析影片文件"""
        import subprocess
        
        try:
            # 使用 ffprobe 獲取影片資訊
            cmd = [
                'ffprobe',
                '-v', 'quiet',
                '-print_format', 'json',
                '-show_format',
                '-show_streams',
                file_path
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            data = json.loads(result.stdout)
            
            analysis = {
                'file_path': file_path,
                'format': data.get('format', {}),
                'streams': data.get('streams', []),
                'issues': [],
                'suggestions': []
            }
            
            # 檢查常見問題
            self._check_video_issues(analysis)
            
            return analysis
            
        except Exception as e:
            return {
                'file_path': file_path,
                'error': str(e),
                'issues': ['無法讀取影片文件'],
                'suggestions': ['檢查文件是否存在且格式正確']
            }
    
    def _check_video_issues(self, analysis: Dict):
        """檢查影片問題"""
        format_info = analysis['format']
        
        # 檢查文件大小
        size_mb = int(format_info.get('size', 0)) / (1024 * 1024)
        if size_mb > 1000:  # 超過 1GB
            analysis['issues'].append(f"文件過大: {size_mb:.2f}MB")
            analysis['suggestions'].append("考慮分段處理或使用更高配置的處理節點")
        
        # 檢查編碼格式
        video_stream = next((s for s in analysis['streams'] if s['codec_type'] == 'video'), None)
        if video_stream:
            codec = video_stream.get('codec_name')
            if codec in ['h265', 'vp9']:
                analysis['suggestions'].append(f"使用 {codec} 編碼，建議啟用硬體加速")
        
        # 檢查幀率
        if video_stream:
            fps = eval(video_stream.get('r_frame_rate', '0/1'))
            if fps > 60:
                analysis['issues'].append(f"高幀率影片: {fps}fps")
                analysis['suggestions'].append("考慮降低幀率以加快處理速度")
```

#### 解決方案

**方案 1: 實現健壯的 FFmpeg 處理器**

```python
class RobustFFmpegProcessor:
    """健壯的 FFmpeg 處理器"""
    
    def __init__(self):
        self.max_retries = 3
        self.timeout = 3600  # 1小時
    
    def process_video(
        self,
        input_path: str,
        output_path: str,
        options: Dict
    ) -> Dict:
        """處理影片"""
        for attempt in range(self.max_retries):
            try:
                result = self._process_with_timeout(
                    input_path,
                    output_path,
                    options,
                    timeout=self.timeout
                )
                
                # 驗證輸出
                if self._validate_output(output_path):
                    return result
                else:
                    raise Exception("輸出文件驗證失敗")
                    
            except subprocess.TimeoutExpired:
                self.logger.warning(f"處理超時，嘗試 {attempt + 1}/{self.max_retries}")
                
                if attempt < self.max_retries - 1:
                    # 嘗試使用更低的質量設置
                    options = self._reduce_quality(options)
                else:
                    raise
                    
            except Exception as e:
                self.logger.error(f"處理失敗: {str(e)}")
                
                if attempt < self.max_retries - 1:
                    time.sleep(2 ** attempt)  # 指數退避
                else:
                    raise
    
    def _process_with_timeout(
        self,
        input_path: str,
        output_path: str,
        options: Dict,
        timeout: int
    ):
        """帶超時的處理"""
        cmd = self._build_ffmpeg_command(input_path, output_path, options)
        
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        try:
            stdout, stderr = process.communicate(timeout=timeout)
            
            if process.returncode != 0:
                raise Exception(f"FFmpeg 錯誤: {stderr}")
            
            return {
                'success': True,
                'output_path': output_path,
                'logs': stderr
            }
            
        except subprocess.TimeoutExpired:
            process.kill()
            raise
    
    def _validate_output(self, output_path: str) -> bool:
        """驗證輸出文件"""
        if not os.path.exists(output_path):
            return False
        
        # 檢查文件大小
        if os.path.getsize(output_path) < 1024:  # 小於 1KB
            return False
        
        # 使用 ffprobe 驗證
        try:
            cmd = ['ffprobe', '-v', 'error', output_path]
            result = subprocess.run(cmd, capture_output=True)
            return result.returncode == 0
        except:
            return False
    
    def _reduce_quality(self, options: Dict) -> Dict:
        """降低質量設置"""
        reduced = options.copy()
        
        # 降低比特率
        if 'video_bitrate' in reduced:
            reduced['video_bitrate'] = int(reduced['video_bitrate'] * 0.7)
        
        # 降低解析度
        if 'scale' in reduced:
            width, height = reduced['scale'].split('x')
            reduced['scale'] = f"{int(width)*0.8}x{int(height)*0.8}"
        
        return reduced
```

---

### 問題 2: 記憶體溢出

#### 症狀
- 處理大文件時記憶體不足
- OOM Killer 終止進程
- 系統響應緩慢

#### 解決方案

```python
class MemoryEfficientProcessor:
    """記憶體高效的處理器"""
    
    def __init__(self, chunk_size_mb=100):
        self.chunk_size = chunk_size_mb * 1024 * 1024
    
    def process_large_video(
        self,
        input_path: str,
        output_dir: str
    ) -> List[str]:
        """分段處理大影片"""
        # 1. 獲取影片時長
        duration = self._get_video_duration(input_path)
        
        # 2. 計算分段
        segments = self._calculate_segments(input_path, duration)
        
        # 3. 分段處理
        output_paths = []
        for i, (start, end) in enumerate(segments):
            segment_path = os.path.join(output_dir, f"segment_{i:04d}.mp4")
            
            self._process_segment(
                input_path,
                segment_path,
                start_time=start,
                end_time=end
            )
            
            output_paths.append(segment_path)
        
        # 4. 合併分段
        final_output = os.path.join(output_dir, "final.mp4")
        self._merge_segments(output_paths, final_output)
        
        # 5. 清理臨時文件
        for path in output_paths:
            os.remove(path)
        
        return final_output
    
    def _calculate_segments(self, input_path: str, duration: float) -> List[tuple]:
        """計算分段"""
        # 估算文件大小
        file_size = os.path.getsize(input_path)
        
        # 計算每段時長
        segment_duration = (self.chunk_size / file_size) * duration
        
        # 生成分段列表
        segments = []
        current = 0
        
        while current < duration:
            end = min(current + segment_duration, duration)
            segments.append((current, end))
            current = end
        
        return segments
    
    def _process_segment(
        self,
        input_path: str,
        output_path: str,
        start_time: float,
        end_time: float
    ):
        """處理單個分段"""
        cmd = [
            'ffmpeg',
            '-ss', str(start_time),
            '-t', str(end_time - start_time),
            '-i', input_path,
            '-c', 'copy',  # 直接複製，不重新編碼
            output_path
        ]
        
        subprocess.run(cmd, check=True)
```

---

### 問題 3: GPU 加速失敗

#### 症狀
- 無法使用 GPU 加速
- CUDA 錯誤
- 處理速度慢

#### 解決方案

```python
class GPUAcceleratedProcessor:
    """GPU 加速處理器"""
    
    def __init__(self):
        self.gpu_available = self._check_gpu_availability()
        self.cuda_devices = self._get_cuda_devices()
    
    def _check_gpu_availability(self) -> bool:
        """檢查 GPU 可用性"""
        try:
            cmd = ['nvidia-smi', '--query-gpu=name', '--format=csv,noheader']
            result = subprocess.run(cmd, capture_output=True, text=True)
            return result.returncode == 0
        except:
            return False
    
    def _get_cuda_devices(self) -> List[int]:
        """獲取 CUDA 設備列表"""
        if not self.gpu_available:
            return []
        
        try:
            cmd = ['nvidia-smi', '--query-gpu=index', '--format=csv,noheader']
            result = subprocess.run(cmd, capture_output=True, text=True)
            return [int(i) for i in result.stdout.strip().split('\n')]
        except:
            return []
    
    def process_with_gpu(
        self,
        input_path: str,
        output_path: str,
        device_id: int = 0
    ):
        """使用 GPU 處理"""
        if not self.gpu_available:
            raise Exception("GPU 不可用，回退到 CPU 處理")
        
        # 構建 FFmpeg 命令（使用 NVENC）
        cmd = [
            'ffmpeg',
            '-hwaccel', 'cuda',
            '-hwaccel_device', str(device_id),
            '-i', input_path,
            '-c:v', 'h264_nvenc',  # NVIDIA 硬體編碼器
            '-preset', 'fast',
            '-b:v', '5M',
            output_path
        ]
        
        try:
            subprocess.run(cmd, check=True, capture_output=True)
        except subprocess.CalledProcessError as e:
            self.logger.warning(f"GPU 處理失敗，回退到 CPU: {e.stderr}")
            # 回退到 CPU 處理
            self._process_with_cpu(input_path, output_path)
```

---

## 📊 效能監控

```yaml
# Prometheus 監控
groups:
  - name: media_processing
    rules:
      - alert: HighProcessingFailureRate
        expr: rate(media_processing_failures_total[5m]) / rate(media_processing_total[5m]) > 0.15
        annotations:
          summary: "媒體處理失敗率過高"
      
      - alert: LongProcessingTime
        expr: histogram_quantile(0.95, rate(media_processing_duration_seconds_bucket[10m])) > 1800
        annotations:
          summary: "處理時間過長（P95 > 30分鐘）"
      
      - alert: HighMemoryUsage
        expr: process_resident_memory_bytes / 1024 / 1024 / 1024 > 8
        annotations:
          summary: "記憶體使用超過 8GB"
```

---

**相關章節**:
- [5.7 效能優化策略](ch5-7-效能優化策略.md)
- [← 返回第5章首頁](ch5-index.md)

