# ç¬¬5ç« ï¼šè‡ªå‹•åŒ–åª’é«”è™•ç†ç®¡é“ (Automated Media Processing Pipeline)

## 5.11 æ•…éšœæ’æŸ¥æŒ‡å—

**[â† è¿”å›ç¬¬5ç« é¦–é ](ch5-index.md)**

---

## ğŸ› å¸¸è¦‹å•é¡Œèˆ‡è§£æ±ºæ–¹æ¡ˆ

### å•é¡Œ 1: å½±ç‰‡è™•ç†å¤±æ•—

#### ç—‡ç‹€
- FFmpeg è™•ç†éŒ¯èª¤
- è½‰ç¢¼ä»»å‹™è¶…æ™‚
- è¼¸å‡ºæ–‡ä»¶æå£

#### è¨ºæ–·å·¥å…·

```python
class MediaProcessingDiagnostics:
    """åª’é«”è™•ç†è¨ºæ–·å·¥å…·"""
    
    def analyze_video_file(self, file_path: str) -> Dict:
        """åˆ†æå½±ç‰‡æ–‡ä»¶"""
        import subprocess
        
        try:
            # ä½¿ç”¨ ffprobe ç²å–å½±ç‰‡è³‡è¨Š
            cmd = [
                'ffprobe',
                '-v', 'quiet',
                '-print_format', 'json',
                '-show_format',
                '-show_streams',
                file_path
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            data = json.loads(result.stdout)
            
            analysis = {
                'file_path': file_path,
                'format': data.get('format', {}),
                'streams': data.get('streams', []),
                'issues': [],
                'suggestions': []
            }
            
            # æª¢æŸ¥å¸¸è¦‹å•é¡Œ
            self._check_video_issues(analysis)
            
            return analysis
            
        except Exception as e:
            return {
                'file_path': file_path,
                'error': str(e),
                'issues': ['ç„¡æ³•è®€å–å½±ç‰‡æ–‡ä»¶'],
                'suggestions': ['æª¢æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”æ ¼å¼æ­£ç¢º']
            }
    
    def _check_video_issues(self, analysis: Dict):
        """æª¢æŸ¥å½±ç‰‡å•é¡Œ"""
        format_info = analysis['format']
        
        # æª¢æŸ¥æ–‡ä»¶å¤§å°
        size_mb = int(format_info.get('size', 0)) / (1024 * 1024)
        if size_mb > 1000:  # è¶…é 1GB
            analysis['issues'].append(f"æ–‡ä»¶éå¤§: {size_mb:.2f}MB")
            analysis['suggestions'].append("è€ƒæ…®åˆ†æ®µè™•ç†æˆ–ä½¿ç”¨æ›´é«˜é…ç½®çš„è™•ç†ç¯€é»")
        
        # æª¢æŸ¥ç·¨ç¢¼æ ¼å¼
        video_stream = next((s for s in analysis['streams'] if s['codec_type'] == 'video'), None)
        if video_stream:
            codec = video_stream.get('codec_name')
            if codec in ['h265', 'vp9']:
                analysis['suggestions'].append(f"ä½¿ç”¨ {codec} ç·¨ç¢¼ï¼Œå»ºè­°å•Ÿç”¨ç¡¬é«”åŠ é€Ÿ")
        
        # æª¢æŸ¥å¹€ç‡
        if video_stream:
            fps = eval(video_stream.get('r_frame_rate', '0/1'))
            if fps > 60:
                analysis['issues'].append(f"é«˜å¹€ç‡å½±ç‰‡: {fps}fps")
                analysis['suggestions'].append("è€ƒæ…®é™ä½å¹€ç‡ä»¥åŠ å¿«è™•ç†é€Ÿåº¦")
```

#### è§£æ±ºæ–¹æ¡ˆ

**æ–¹æ¡ˆ 1: å¯¦ç¾å¥å£¯çš„ FFmpeg è™•ç†å™¨**

```python
class RobustFFmpegProcessor:
    """å¥å£¯çš„ FFmpeg è™•ç†å™¨"""
    
    def __init__(self):
        self.max_retries = 3
        self.timeout = 3600  # 1å°æ™‚
    
    def process_video(
        self,
        input_path: str,
        output_path: str,
        options: Dict
    ) -> Dict:
        """è™•ç†å½±ç‰‡"""
        for attempt in range(self.max_retries):
            try:
                result = self._process_with_timeout(
                    input_path,
                    output_path,
                    options,
                    timeout=self.timeout
                )
                
                # é©—è­‰è¼¸å‡º
                if self._validate_output(output_path):
                    return result
                else:
                    raise Exception("è¼¸å‡ºæ–‡ä»¶é©—è­‰å¤±æ•—")
                    
            except subprocess.TimeoutExpired:
                self.logger.warning(f"è™•ç†è¶…æ™‚ï¼Œå˜—è©¦ {attempt + 1}/{self.max_retries}")
                
                if attempt < self.max_retries - 1:
                    # å˜—è©¦ä½¿ç”¨æ›´ä½çš„è³ªé‡è¨­ç½®
                    options = self._reduce_quality(options)
                else:
                    raise
                    
            except Exception as e:
                self.logger.error(f"è™•ç†å¤±æ•—: {str(e)}")
                
                if attempt < self.max_retries - 1:
                    time.sleep(2 ** attempt)  # æŒ‡æ•¸é€€é¿
                else:
                    raise
    
    def _process_with_timeout(
        self,
        input_path: str,
        output_path: str,
        options: Dict,
        timeout: int
    ):
        """å¸¶è¶…æ™‚çš„è™•ç†"""
        cmd = self._build_ffmpeg_command(input_path, output_path, options)
        
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        try:
            stdout, stderr = process.communicate(timeout=timeout)
            
            if process.returncode != 0:
                raise Exception(f"FFmpeg éŒ¯èª¤: {stderr}")
            
            return {
                'success': True,
                'output_path': output_path,
                'logs': stderr
            }
            
        except subprocess.TimeoutExpired:
            process.kill()
            raise
    
    def _validate_output(self, output_path: str) -> bool:
        """é©—è­‰è¼¸å‡ºæ–‡ä»¶"""
        if not os.path.exists(output_path):
            return False
        
        # æª¢æŸ¥æ–‡ä»¶å¤§å°
        if os.path.getsize(output_path) < 1024:  # å°æ–¼ 1KB
            return False
        
        # ä½¿ç”¨ ffprobe é©—è­‰
        try:
            cmd = ['ffprobe', '-v', 'error', output_path]
            result = subprocess.run(cmd, capture_output=True)
            return result.returncode == 0
        except:
            return False
    
    def _reduce_quality(self, options: Dict) -> Dict:
        """é™ä½è³ªé‡è¨­ç½®"""
        reduced = options.copy()
        
        # é™ä½æ¯”ç‰¹ç‡
        if 'video_bitrate' in reduced:
            reduced['video_bitrate'] = int(reduced['video_bitrate'] * 0.7)
        
        # é™ä½è§£æåº¦
        if 'scale' in reduced:
            width, height = reduced['scale'].split('x')
            reduced['scale'] = f"{int(width)*0.8}x{int(height)*0.8}"
        
        return reduced
```

---

### å•é¡Œ 2: è¨˜æ†¶é«”æº¢å‡º

#### ç—‡ç‹€
- è™•ç†å¤§æ–‡ä»¶æ™‚è¨˜æ†¶é«”ä¸è¶³
- OOM Killer çµ‚æ­¢é€²ç¨‹
- ç³»çµ±éŸ¿æ‡‰ç·©æ…¢

#### è§£æ±ºæ–¹æ¡ˆ

```python
class MemoryEfficientProcessor:
    """è¨˜æ†¶é«”é«˜æ•ˆçš„è™•ç†å™¨"""
    
    def __init__(self, chunk_size_mb=100):
        self.chunk_size = chunk_size_mb * 1024 * 1024
    
    def process_large_video(
        self,
        input_path: str,
        output_dir: str
    ) -> List[str]:
        """åˆ†æ®µè™•ç†å¤§å½±ç‰‡"""
        # 1. ç²å–å½±ç‰‡æ™‚é•·
        duration = self._get_video_duration(input_path)
        
        # 2. è¨ˆç®—åˆ†æ®µ
        segments = self._calculate_segments(input_path, duration)
        
        # 3. åˆ†æ®µè™•ç†
        output_paths = []
        for i, (start, end) in enumerate(segments):
            segment_path = os.path.join(output_dir, f"segment_{i:04d}.mp4")
            
            self._process_segment(
                input_path,
                segment_path,
                start_time=start,
                end_time=end
            )
            
            output_paths.append(segment_path)
        
        # 4. åˆä½µåˆ†æ®µ
        final_output = os.path.join(output_dir, "final.mp4")
        self._merge_segments(output_paths, final_output)
        
        # 5. æ¸…ç†è‡¨æ™‚æ–‡ä»¶
        for path in output_paths:
            os.remove(path)
        
        return final_output
    
    def _calculate_segments(self, input_path: str, duration: float) -> List[tuple]:
        """è¨ˆç®—åˆ†æ®µ"""
        # ä¼°ç®—æ–‡ä»¶å¤§å°
        file_size = os.path.getsize(input_path)
        
        # è¨ˆç®—æ¯æ®µæ™‚é•·
        segment_duration = (self.chunk_size / file_size) * duration
        
        # ç”Ÿæˆåˆ†æ®µåˆ—è¡¨
        segments = []
        current = 0
        
        while current < duration:
            end = min(current + segment_duration, duration)
            segments.append((current, end))
            current = end
        
        return segments
    
    def _process_segment(
        self,
        input_path: str,
        output_path: str,
        start_time: float,
        end_time: float
    ):
        """è™•ç†å–®å€‹åˆ†æ®µ"""
        cmd = [
            'ffmpeg',
            '-ss', str(start_time),
            '-t', str(end_time - start_time),
            '-i', input_path,
            '-c', 'copy',  # ç›´æ¥è¤‡è£½ï¼Œä¸é‡æ–°ç·¨ç¢¼
            output_path
        ]
        
        subprocess.run(cmd, check=True)
```

---

### å•é¡Œ 3: GPU åŠ é€Ÿå¤±æ•—

#### ç—‡ç‹€
- ç„¡æ³•ä½¿ç”¨ GPU åŠ é€Ÿ
- CUDA éŒ¯èª¤
- è™•ç†é€Ÿåº¦æ…¢

#### è§£æ±ºæ–¹æ¡ˆ

```python
class GPUAcceleratedProcessor:
    """GPU åŠ é€Ÿè™•ç†å™¨"""
    
    def __init__(self):
        self.gpu_available = self._check_gpu_availability()
        self.cuda_devices = self._get_cuda_devices()
    
    def _check_gpu_availability(self) -> bool:
        """æª¢æŸ¥ GPU å¯ç”¨æ€§"""
        try:
            cmd = ['nvidia-smi', '--query-gpu=name', '--format=csv,noheader']
            result = subprocess.run(cmd, capture_output=True, text=True)
            return result.returncode == 0
        except:
            return False
    
    def _get_cuda_devices(self) -> List[int]:
        """ç²å– CUDA è¨­å‚™åˆ—è¡¨"""
        if not self.gpu_available:
            return []
        
        try:
            cmd = ['nvidia-smi', '--query-gpu=index', '--format=csv,noheader']
            result = subprocess.run(cmd, capture_output=True, text=True)
            return [int(i) for i in result.stdout.strip().split('\n')]
        except:
            return []
    
    def process_with_gpu(
        self,
        input_path: str,
        output_path: str,
        device_id: int = 0
    ):
        """ä½¿ç”¨ GPU è™•ç†"""
        if not self.gpu_available:
            raise Exception("GPU ä¸å¯ç”¨ï¼Œå›é€€åˆ° CPU è™•ç†")
        
        # æ§‹å»º FFmpeg å‘½ä»¤ï¼ˆä½¿ç”¨ NVENCï¼‰
        cmd = [
            'ffmpeg',
            '-hwaccel', 'cuda',
            '-hwaccel_device', str(device_id),
            '-i', input_path,
            '-c:v', 'h264_nvenc',  # NVIDIA ç¡¬é«”ç·¨ç¢¼å™¨
            '-preset', 'fast',
            '-b:v', '5M',
            output_path
        ]
        
        try:
            subprocess.run(cmd, check=True, capture_output=True)
        except subprocess.CalledProcessError as e:
            self.logger.warning(f"GPU è™•ç†å¤±æ•—ï¼Œå›é€€åˆ° CPU: {e.stderr}")
            # å›é€€åˆ° CPU è™•ç†
            self._process_with_cpu(input_path, output_path)
```

---

## ğŸ“Š æ•ˆèƒ½ç›£æ§

```yaml
# Prometheus ç›£æ§
groups:
  - name: media_processing
    rules:
      - alert: HighProcessingFailureRate
        expr: rate(media_processing_failures_total[5m]) / rate(media_processing_total[5m]) > 0.15
        annotations:
          summary: "åª’é«”è™•ç†å¤±æ•—ç‡éé«˜"
      
      - alert: LongProcessingTime
        expr: histogram_quantile(0.95, rate(media_processing_duration_seconds_bucket[10m])) > 1800
        annotations:
          summary: "è™•ç†æ™‚é–“éé•·ï¼ˆP95 > 30åˆ†é˜ï¼‰"
      
      - alert: HighMemoryUsage
        expr: process_resident_memory_bytes / 1024 / 1024 / 1024 > 8
        annotations:
          summary: "è¨˜æ†¶é«”ä½¿ç”¨è¶…é 8GB"
```

---

**ç›¸é—œç« ç¯€**:
- [5.7 æ•ˆèƒ½å„ªåŒ–ç­–ç•¥](ch5-7-æ•ˆèƒ½å„ªåŒ–ç­–ç•¥.md)
- [â† è¿”å›ç¬¬5ç« é¦–é ](ch5-index.md)

