# ç¬¬3ç« ï¼šè³‡æ–™æºå¥åº·ç›£æ¸¬ç³»çµ± (Data Source Health Monitoring)

## 3.11 æ•…éšœæ’æŸ¥æŒ‡å—

**[â† è¿”å›ç¬¬3ç« é¦–é ](ch3-index.md)**

---

## ğŸ› å¸¸è¦‹å•é¡Œ

### å•é¡Œ 1: å¥åº·æª¢æŸ¥è¶…æ™‚

#### ç—‡ç‹€
- å¤§é‡è³‡æ–™æºæª¢æŸ¥è¶…æ™‚
- ç›£æ§ä»»å‹™å †ç©
- éŸ¿æ‡‰æ™‚é–“éé•·

#### è§£æ±ºæ–¹æ¡ˆ

```python
# å„ªåŒ–å¥åº·æª¢æŸ¥é…ç½®
class OptimizedHealthChecker:
    """å„ªåŒ–çš„å¥åº·æª¢æŸ¥å™¨"""
    
    def __init__(self, timeout=5, max_workers=20):
        self.timeout = timeout
        self.max_workers = max_workers
        self.session = self._create_session()
    
    def _create_session(self):
        """å‰µå»ºå„ªåŒ–çš„ Session"""
        session = requests.Session()
        
        # é…ç½®é€£æ¥æ± 
        adapter = HTTPAdapter(
            pool_connections=100,
            pool_maxsize=100,
            max_retries=Retry(
                total=2,
                backoff_factor=0.3,
                status_forcelist=[500, 502, 503, 504]
            )
        )
        
        session.mount('http://', adapter)
        session.mount('https://', adapter)
        
        # è¨­ç½®è¶…æ™‚
        session.timeout = self.timeout
        
        return session
    
    def check_batch(self, data_sources: List[DataSource]) -> List[Dict]:
        """æ‰¹é‡æª¢æŸ¥ï¼ˆä¸¦è¡Œï¼‰"""
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            futures = {
                executor.submit(self.check_single, ds): ds 
                for ds in data_sources
            }
            
            results = []
            for future in as_completed(futures, timeout=self.timeout*2):
                try:
                    result = future.result(timeout=1)
                    results.append(result)
                except TimeoutError:
                    ds = futures[future]
                    results.append({
                        'id': ds.id,
                        'status': 'timeout',
                        'response_time': self.timeout * 1000
                    })
                except Exception as e:
                    ds = futures[future]
                    results.append({
                        'id': ds.id,
                        'status': 'error',
                        'error': str(e)
                    })
            
            return results
```

---

### å•é¡Œ 2: å‘Šè­¦é¢¨æš´

#### ç—‡ç‹€
- çŸ­æ™‚é–“å…§å¤§é‡å‘Šè­¦
- å‘Šè­¦é€šé“è¢«æ‰“çˆ†
- ç„¡æ³•è­˜åˆ¥çœŸæ­£çš„å•é¡Œ

#### è§£æ±ºæ–¹æ¡ˆ

```python
class AlertThrottler:
    """å‘Šè­¦é™æµå™¨"""
    
    def __init__(self, redis_client):
        self.redis = redis_client
        self.rules = {
            'same_source_same_type': {'window': 300, 'max_count': 3},  # 5åˆ†é˜å…§åŒé¡å‹æœ€å¤š3æ¬¡
            'same_source_any_type': {'window': 3600, 'max_count': 10},  # 1å°æ™‚å…§æœ€å¤š10æ¬¡
            'global_rate': {'window': 60, 'max_count': 100}  # 1åˆ†é˜å…§å…¨å±€æœ€å¤š100æ¬¡
        }
    
    def should_send_alert(self, alert: Dict) -> bool:
        """åˆ¤æ–·æ˜¯å¦æ‡‰è©²ç™¼é€å‘Šè­¦"""
        # æª¢æŸ¥å„é …è¦å‰‡
        for rule_name, rule_config in self.rules.items():
            if not self._check_rule(alert, rule_name, rule_config):
                logging.info(f"å‘Šè­¦è¢«é™æµ [{rule_name}]: {alert['source_id']}")
                return False
        
        return True
    
    def _check_rule(self, alert: Dict, rule_name: str, config: Dict) -> bool:
        """æª¢æŸ¥å–®å€‹è¦å‰‡"""
        key = self._get_rule_key(alert, rule_name)
        window = config['window']
        max_count = config['max_count']
        
        # ç²å–è¨ˆæ•¸
        current = self.redis.get(key)
        count = int(current) if current else 0
        
        if count >= max_count:
            return False
        
        # å¢åŠ è¨ˆæ•¸
        pipe = self.redis.pipeline()
        pipe.incr(key)
        pipe.expire(key, window)
        pipe.execute()
        
        return True
```

---

## ğŸ“Š ç›£æ§æŒ‡æ¨™

```yaml
# Prometheus é…ç½®
groups:
  - name: health_monitoring
    rules:
      - alert: HighCheckFailureRate
        expr: rate(health_check_failures_total[5m]) / rate(health_checks_total[5m]) > 0.2
        annotations:
          summary: "å¥åº·æª¢æŸ¥å¤±æ•—ç‡éé«˜"
      
      - alert: CheckQueueBacklog
        expr: health_check_queue_size > 1000
        for: 5m
        annotations:
          summary: "æª¢æŸ¥éšŠåˆ—ç©å£“"
```

---

**ç›¸é—œç« ç¯€**:
- [3.7 æ•ˆèƒ½å„ªåŒ–ç­–ç•¥](ch3-7-æ•ˆèƒ½å„ªåŒ–ç­–ç•¥.md)
- [â† è¿”å›ç¬¬3ç« é¦–é ](ch3-index.md)

