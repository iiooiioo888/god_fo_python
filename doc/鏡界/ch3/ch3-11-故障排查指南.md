# 第3章：資料源健康監測系統 (Data Source Health Monitoring)

## 3.11 故障排查指南

**[← 返回第3章首頁](ch3-index.md)**

---

## 🐛 常見問題

### 問題 1: 健康檢查超時

#### 症狀
- 大量資料源檢查超時
- 監控任務堆積
- 響應時間過長

#### 解決方案

```python
# 優化健康檢查配置
class OptimizedHealthChecker:
    """優化的健康檢查器"""
    
    def __init__(self, timeout=5, max_workers=20):
        self.timeout = timeout
        self.max_workers = max_workers
        self.session = self._create_session()
    
    def _create_session(self):
        """創建優化的 Session"""
        session = requests.Session()
        
        # 配置連接池
        adapter = HTTPAdapter(
            pool_connections=100,
            pool_maxsize=100,
            max_retries=Retry(
                total=2,
                backoff_factor=0.3,
                status_forcelist=[500, 502, 503, 504]
            )
        )
        
        session.mount('http://', adapter)
        session.mount('https://', adapter)
        
        # 設置超時
        session.timeout = self.timeout
        
        return session
    
    def check_batch(self, data_sources: List[DataSource]) -> List[Dict]:
        """批量檢查（並行）"""
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            futures = {
                executor.submit(self.check_single, ds): ds 
                for ds in data_sources
            }
            
            results = []
            for future in as_completed(futures, timeout=self.timeout*2):
                try:
                    result = future.result(timeout=1)
                    results.append(result)
                except TimeoutError:
                    ds = futures[future]
                    results.append({
                        'id': ds.id,
                        'status': 'timeout',
                        'response_time': self.timeout * 1000
                    })
                except Exception as e:
                    ds = futures[future]
                    results.append({
                        'id': ds.id,
                        'status': 'error',
                        'error': str(e)
                    })
            
            return results
```

---

### 問題 2: 告警風暴

#### 症狀
- 短時間內大量告警
- 告警通道被打爆
- 無法識別真正的問題

#### 解決方案

```python
class AlertThrottler:
    """告警限流器"""
    
    def __init__(self, redis_client):
        self.redis = redis_client
        self.rules = {
            'same_source_same_type': {'window': 300, 'max_count': 3},  # 5分鐘內同類型最多3次
            'same_source_any_type': {'window': 3600, 'max_count': 10},  # 1小時內最多10次
            'global_rate': {'window': 60, 'max_count': 100}  # 1分鐘內全局最多100次
        }
    
    def should_send_alert(self, alert: Dict) -> bool:
        """判斷是否應該發送告警"""
        # 檢查各項規則
        for rule_name, rule_config in self.rules.items():
            if not self._check_rule(alert, rule_name, rule_config):
                logging.info(f"告警被限流 [{rule_name}]: {alert['source_id']}")
                return False
        
        return True
    
    def _check_rule(self, alert: Dict, rule_name: str, config: Dict) -> bool:
        """檢查單個規則"""
        key = self._get_rule_key(alert, rule_name)
        window = config['window']
        max_count = config['max_count']
        
        # 獲取計數
        current = self.redis.get(key)
        count = int(current) if current else 0
        
        if count >= max_count:
            return False
        
        # 增加計數
        pipe = self.redis.pipeline()
        pipe.incr(key)
        pipe.expire(key, window)
        pipe.execute()
        
        return True
```

---

## 📊 監控指標

```yaml
# Prometheus 配置
groups:
  - name: health_monitoring
    rules:
      - alert: HighCheckFailureRate
        expr: rate(health_check_failures_total[5m]) / rate(health_checks_total[5m]) > 0.2
        annotations:
          summary: "健康檢查失敗率過高"
      
      - alert: CheckQueueBacklog
        expr: health_check_queue_size > 1000
        for: 5m
        annotations:
          summary: "檢查隊列積壓"
```

---

**相關章節**:
- [3.7 效能優化策略](ch3-7-效能優化策略.md)
- [← 返回第3章首頁](ch3-index.md)

