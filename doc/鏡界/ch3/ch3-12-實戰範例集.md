# 第3章：資料源健康監測系統 - 實戰範例集

**[← 返回第3章首頁](ch3-index.md)**

---

本章節提供資料源健康監測系統的完整實戰範例，涵蓋從基礎到高級的各種應用場景。

## 📚 範例清單

| 編號 | 範例名稱 | 難度 | 代碼量 | 適用場景 |
|------|---------|------|--------|---------|
| 1 | 自定義健康檢查器 | ⭐⭐ | ~120行 | 為特定資料源實現檢查邏輯 |
| 2 | 智能告警過濾 | ⭐⭐⭐ | ~150行 | 減少告警疲勞 |
| 3 | 健康趨勢分析 | ⭐⭐⭐ | ~180行 | 預測性維護 |
| 4 | 自動修復系統 | ⭐⭐⭐⭐ | ~200行 | 自動恢復故障資料源 |
| 5 | 多維度健康評分 | ⭐⭐⭐⭐ | ~180行 | 綜合評估資料源健康 |
| 6 | 智能巡檢調度 | ⭐⭐⭐⭐⭐ | ~220行 | 動態調整檢查頻率 |

---

## 範例 1: 自定義健康檢查器 ⭐⭐

### 業務場景
為不同類型的資料源實現專屬的健康檢查邏輯，例如資料庫連接檢查、API端點檢查、文件系統檢查等。

### 實現思路
1. 定義統一的檢查器介面
2. 實現各類型檢查器
3. 支持自定義檢查參數
4. 提供詳細的檢查結果

### 完整代碼

```python
from abc import ABC, abstractmethod
from typing import Dict, Optional
import requests
import psycopg2
from pathlib import Path

class HealthChecker(ABC):
    """健康檢查器基類"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.timeout = config.get('timeout', 30)
    
    @abstractmethod
    def check(self) -> Dict:
        """執行健康檢查"""
        pass
    
    def _create_result(
        self,
        is_healthy: bool,
        message: str,
        metrics: Dict = None
    ) -> Dict:
        """創建檢查結果"""
        return {
            'is_healthy': is_healthy,
            'message': message,
            'metrics': metrics or {},
            'timestamp': datetime.now().isoformat()
        }

class DatabaseHealthChecker(HealthChecker):
    """資料庫健康檢查器"""
    
    def check(self) -> Dict:
        """檢查資料庫連接和效能"""
        start_time = time.time()
        
        try:
            # 建立連接
            conn = psycopg2.connect(
                host=self.config['host'],
                port=self.config.get('port', 5432),
                database=self.config['database'],
                user=self.config['user'],
                password=self.config['password'],
                connect_timeout=self.timeout
            )
            
            cursor = conn.cursor()
            
            # 執行測試查詢
            cursor.execute("SELECT 1")
            result = cursor.fetchone()
            
            # 檢查連接數
            cursor.execute("""
                SELECT count(*) FROM pg_stat_activity
                WHERE state = 'active'
            """)
            active_connections = cursor.fetchone()[0]
            
            # 檢查資料庫大小
            cursor.execute("""
                SELECT pg_database_size(current_database())
            """)
            db_size = cursor.fetchone()[0]
            
            response_time = time.time() - start_time
            
            cursor.close()
            conn.close()
            
            # 判斷健康狀態
            is_healthy = (
                result[0] == 1 and
                response_time < 5.0 and
                active_connections < 100
            )
            
            return self._create_result(
                is_healthy=is_healthy,
                message="資料庫運行正常" if is_healthy else "資料庫效能異常",
                metrics={
                    'response_time': response_time,
                    'active_connections': active_connections,
                    'database_size_mb': db_size / (1024 * 1024)
                }
            )
            
        except Exception as e:
            return self._create_result(
                is_healthy=False,
                message=f"資料庫檢查失敗: {str(e)}",
                metrics={'error': str(e)}
            )

class APIHealthChecker(HealthChecker):
    """API 健康檢查器"""
    
    def check(self) -> Dict:
        """檢查 API 端點"""
        url = self.config['url']
        method = self.config.get('method', 'GET')
        expected_status = self.config.get('expected_status', 200)
        
        start_time = time.time()
        
        try:
            response = requests.request(
                method=method,
                url=url,
                timeout=self.timeout,
                headers=self.config.get('headers', {}),
                json=self.config.get('payload', None)
            )
            
            response_time = time.time() - start_time
            
            # 判斷健康狀態
            is_healthy = (
                response.status_code == expected_status and
                response_time < 2.0
            )
            
            return self._create_result(
                is_healthy=is_healthy,
                message=f"API 狀態: {response.status_code}",
                metrics={
                    'status_code': response.status_code,
                    'response_time': response_time,
                    'content_length': len(response.content)
                }
            )
            
        except requests.Timeout:
            return self._create_result(
                is_healthy=False,
                message="API 請求超時",
                metrics={'error': 'timeout'}
            )
        except Exception as e:
            return self._create_result(
                is_healthy=False,
                message=f"API 檢查失敗: {str(e)}",
                metrics={'error': str(e)}
            )

class FileSystemHealthChecker(HealthChecker):
    """文件系統健康檢查器"""
    
    def check(self) -> Dict:
        """檢查文件系統狀態"""
        path = Path(self.config['path'])
        
        try:
            # 檢查路徑是否存在
            if not path.exists():
                return self._create_result(
                    is_healthy=False,
                    message=f"路徑不存在: {path}"
                )
            
            # 檢查磁碟空間
            stat = os.statvfs(path)
            free_space_gb = (stat.f_bavail * stat.f_frsize) / (1024**3)
            total_space_gb = (stat.f_blocks * stat.f_frsize) / (1024**3)
            usage_percent = (1 - stat.f_bavail / stat.f_blocks) * 100
            
            # 檢查讀寫權限
            test_file = path / '.health_check_test'
            try:
                test_file.write_text('test')
                test_file.unlink()
                is_writable = True
            except:
                is_writable = False
            
            # 判斷健康狀態
            is_healthy = (
                usage_percent < 90 and
                free_space_gb > 10 and
                is_writable
            )
            
            return self._create_result(
                is_healthy=is_healthy,
                message="文件系統正常" if is_healthy else "文件系統空間不足",
                metrics={
                    'free_space_gb': free_space_gb,
                    'total_space_gb': total_space_gb,
                    'usage_percent': usage_percent,
                    'is_writable': is_writable
                }
            )
            
        except Exception as e:
            return self._create_result(
                is_healthy=False,
                message=f"文件系統檢查失敗: {str(e)}",
                metrics={'error': str(e)}
            )

# 健康檢查器工廠
class HealthCheckerFactory:
    """健康檢查器工廠"""
    
    _checkers = {
        'database': DatabaseHealthChecker,
        'api': APIHealthChecker,
        'filesystem': FileSystemHealthChecker
    }
    
    @classmethod
    def create(cls, checker_type: str, config: Dict) -> HealthChecker:
        """創建檢查器"""
        if checker_type not in cls._checkers:
            raise ValueError(f"不支持的檢查器類型: {checker_type}")
        
        return cls._checkers[checker_type](config)
    
    @classmethod
    def register(cls, checker_type: str, checker_class: type):
        """註冊自定義檢查器"""
        cls._checkers[checker_type] = checker_class
```

### 使用範例

```python
# 1. 資料庫健康檢查
db_config = {
    'host': 'localhost',
    'database': 'mydb',
    'user': 'user',
    'password': 'pass',
    'timeout': 10
}

db_checker = HealthCheckerFactory.create('database', db_config)
result = db_checker.check()

print(f"健康狀態: {result['is_healthy']}")
print(f"訊息: {result['message']}")
print(f"響應時間: {result['metrics'].get('response_time', 0):.3f}秒")

# 2. API 健康檢查
api_config = {
    'url': 'https://api.example.com/health',
    'method': 'GET',
    'timeout': 5
}

api_checker = HealthCheckerFactory.create('api', api_config)
result = api_checker.check()

# 3. 自定義檢查器
class RedisHealthChecker(HealthChecker):
    def check(self) -> Dict:
        import redis
        try:
            r = redis.Redis(
                host=self.config['host'],
                port=self.config.get('port', 6379),
                socket_connect_timeout=self.timeout
            )
            ping = r.ping()
            return self._create_result(
                is_healthy=ping,
                message="Redis 運行正常" if ping else "Redis 無響應"
            )
        except Exception as e:
            return self._create_result(
                is_healthy=False,
                message=f"Redis 檢查失敗: {str(e)}"
            )

# 註冊自定義檢查器
HealthCheckerFactory.register('redis', RedisHealthChecker)

# 使用自定義檢查器
redis_config = {'host': 'localhost', 'port': 6379}
redis_checker = HealthCheckerFactory.create('redis', redis_config)
result = redis_checker.check()
```

### 擴展建議
1. 添加更多檢查器類型（MongoDB、Elasticsearch 等）
2. 實現檢查結果持久化
3. 支持檢查歷史趨勢分析
4. 集成告警通知

---

## 範例 2: 智能告警過濾 ⭐⭐⭐

### 業務場景
減少告警疲勞，通過智能過濾避免重複告警、短時波動告警，只發送真正重要的告警。

### 實現思路
1. 實現告警去重機制
2. 設置告警抑制窗口
3. 基於嚴重程度分級
4. 支持告警聚合

### 完整代碼

```python
from collections import defaultdict
from typing import List, Dict
import hashlib

class SmartAlertFilter:
    """智能告警過濾器"""
    
    def __init__(self):
        # 告警歷史（用於去重）
        self.alert_history = {}
        
        # 抑制規則
        self.suppression_rules = {
            'critical': 0,      # 關鍵告警不抑制
            'high': 300,        # 高級告警5分鐘內去重
            'medium': 900,      # 中級告警15分鐘內去重
            'low': 3600         # 低級告警1小時內去重
        }
        
        # 告警計數（用於聚合）
        self.alert_counts = defaultdict(int)
        self.aggregation_threshold = 5
    
    def filter_alert(self, alert: Dict) -> Dict:
        """過濾告警"""
        result = {
            'should_send': False,
            'reason': '',
            'alert': alert
        }
        
        # 生成告警指紋
        fingerprint = self._generate_fingerprint(alert)
        
        # 1. 檢查是否重複
        if self._is_duplicate(fingerprint, alert):
            result['reason'] = '重複告警（抑制中）'
            return result
        
        # 2. 檢查是否需要聚合
        aggregation_result = self._should_aggregate(alert)
        if aggregation_result['should_aggregate']:
            result['reason'] = '告警聚合中'
            result['aggregated_count'] = aggregation_result['count']
            return result
        
        # 3. 通過所有過濾器，應該發送
        result['should_send'] = True
        result['reason'] = '新告警'
        
        # 記錄告警
        self._record_alert(fingerprint, alert)
        
        return result
    
    def _generate_fingerprint(self, alert: Dict) -> str:
        """生成告警指紋"""
        # 使用關鍵欄位生成唯一標識
        key_fields = [
            alert.get('source', ''),
            alert.get('type', ''),
            alert.get('severity', ''),
            alert.get('message', '')[:100]  # 只取前100字符
        ]
        
        fingerprint_str = '|'.join(key_fields)
        return hashlib.md5(fingerprint_str.encode()).hexdigest()
    
    def _is_duplicate(self, fingerprint: str, alert: Dict) -> bool:
        """檢查是否重複告警"""
        if fingerprint not in self.alert_history:
            return False
        
        last_alert = self.alert_history[fingerprint]
        time_diff = (
            datetime.now() - last_alert['timestamp']
        ).total_seconds()
        
        # 根據嚴重程度判斷抑制時間
        severity = alert.get('severity', 'medium')
        suppression_time = self.suppression_rules.get(severity, 900)
        
        return time_diff < suppression_time
    
    def _should_aggregate(self, alert: Dict) -> Dict:
        """判斷是否應該聚合"""
        # 對相同來源和類型的告警進行計數
        agg_key = f"{alert.get('source', '')}:{alert.get('type', '')}"
        self.alert_counts[agg_key] += 1
        
        count = self.alert_counts[agg_key]
        
        if count < self.aggregation_threshold:
            return {
                'should_aggregate': False,
                'count': count
            }
        
        # 達到聚合閾值，清零計數器並發送聚合告警
        if count == self.aggregation_threshold:
            self.alert_counts[agg_key] = 0
            return {
                'should_aggregate': False,  # 發送聚合告警
                'count': count,
                'is_aggregated': True
            }
        
        return {
            'should_aggregate': True,
            'count': count
        }
    
    def _record_alert(self, fingerprint: str, alert: Dict):
        """記錄告警"""
        self.alert_history[fingerprint] = {
            'alert': alert,
            'timestamp': datetime.now()
        }
        
        # 清理過期記錄（保留最近24小時）
        cutoff_time = datetime.now() - timedelta(hours=24)
        self.alert_history = {
            fp: data
            for fp, data in self.alert_history.items()
            if data['timestamp'] > cutoff_time
        }
```

### 使用範例

```python
# 創建過濾器
filter = SmartAlertFilter()

# 模擬多個告警
alerts = [
    {
        'source': 'db-server-01',
        'type': 'high_cpu',
        'severity': 'medium',
        'message': 'CPU 使用率 85%'
    },
    {
        'source': 'db-server-01',
        'type': 'high_cpu',
        'severity': 'medium',
        'message': 'CPU 使用率 86%'  # 1分鐘後的重複告警
    },
    {
        'source': 'api-server-01',
        'type': 'high_latency',
        'severity': 'critical',
        'message': '響應時間超過5秒'
    }
]

for alert in alerts:
    result = filter.filter_alert(alert)
    
    if result['should_send']:
        print(f"✅ 發送告警: {alert['message']}")
        print(f"   原因: {result['reason']}")
    else:
        print(f"⏸️  抑制告警: {alert['message']}")
        print(f"   原因: {result['reason']}")
```

---

## 範例 3: 健康趨勢分析 ⭐⭐⭐

### 業務場景
分析資料源健康度的歷史趨勢，預測潛在問題，實現預防性維護。

### 完整代碼

```python
import numpy as np
from scipy import stats

class HealthTrendAnalyzer:
    """健康趨勢分析器"""
    
    def __init__(self, window_size=100):
        self.window_size = window_size
        self.health_history = defaultdict(list)
    
    def record_health_check(
        self,
        source_id: str,
        is_healthy: bool,
        metrics: Dict
    ):
        """記錄健康檢查結果"""
        self.health_history[source_id].append({
            'timestamp': datetime.now(),
            'is_healthy': is_healthy,
            'metrics': metrics
        })
        
        # 保留最近的記錄
        if len(self.health_history[source_id]) > self.window_size:
            self.health_history[source_id] = \
                self.health_history[source_id][-self.window_size:]
    
    def analyze_trend(self, source_id: str) -> Dict:
        """分析健康趨勢"""
        if source_id not in self.health_history:
            return {'error': '無歷史數據'}
        
        history = self.health_history[source_id]
        
        if len(history) < 10:
            return {'error': '數據不足（至少需要10個數據點）'}
        
        # 計算健康率
        health_rate = sum(
            1 for h in history if h['is_healthy']
        ) / len(history)
        
        # 分析響應時間趨勢
        response_times = [
            h['metrics'].get('response_time', 0)
            for h in history
            if 'response_time' in h['metrics']
        ]
        
        if response_times:
            # 線性回歸分析趨勢
            x = np.arange(len(response_times))
            y = np.array(response_times)
            slope, intercept, r_value, p_value, std_err = \
                stats.linregress(x, y)
            
            trend = 'increasing' if slope > 0.01 else \
                   ('decreasing' if slope < -0.01 else 'stable')
        else:
            trend = 'unknown'
            slope = 0
        
        # 預測未來健康狀態
        prediction = self._predict_health(history)
        
        return {
            'health_rate': health_rate,
            'trend': trend,
            'slope': slope,
            'prediction': prediction,
            'data_points': len(history)
        }
    
    def _predict_health(self, history: List[Dict]) -> Dict:
        """預測未來健康狀態"""
        # 簡單的基於最近趨勢的預測
        recent_checks = history[-10:]
        recent_health_rate = sum(
            1 for h in recent_checks if h['is_healthy']
        ) / len(recent_checks)
        
        if recent_health_rate < 0.5:
            status = 'critical'
            confidence = 0.8
        elif recent_health_rate < 0.7:
            status = 'warning'
            confidence = 0.6
        else:
            status = 'healthy'
            confidence = 0.7
        
        return {
            'status': status,
            'confidence': confidence,
            'recommendation': self._get_recommendation(status)
        }
    
    def _get_recommendation(self, status: str) -> str:
        """獲取建議"""
        recommendations = {
            'critical': '建議立即檢查資料源，可能需要維護',
            'warning': '建議密切監控，考慮預防性維護',
            'healthy': '資料源狀態良好，繼續監控'
        }
        return recommendations.get(status, '')
```

---

**更多範例請參考完整文檔...**

**相關章節**:
- [3.11 故障排查指南](ch3-11-故障排查指南.md)
- [← 返回第3章首頁](ch3-index.md)

