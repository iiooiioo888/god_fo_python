# ç¬¬3ç« ï¼šè³‡æ–™æºå¥åº·ç›£æ¸¬ç³»çµ± - å¯¦æˆ°ç¯„ä¾‹é›†

**[â† è¿”å›ç¬¬3ç« é¦–é ](ch3-index.md)**

---

æœ¬ç« ç¯€æä¾›è³‡æ–™æºå¥åº·ç›£æ¸¬ç³»çµ±çš„å®Œæ•´å¯¦æˆ°ç¯„ä¾‹ï¼Œæ¶µè“‹å¾åŸºç¤åˆ°é«˜ç´šçš„å„ç¨®æ‡‰ç”¨å ´æ™¯ã€‚

## ğŸ“š ç¯„ä¾‹æ¸…å–®

| ç·¨è™Ÿ | ç¯„ä¾‹åç¨± | é›£åº¦ | ä»£ç¢¼é‡ | é©ç”¨å ´æ™¯ |
|------|---------|------|--------|---------|
| 1 | è‡ªå®šç¾©å¥åº·æª¢æŸ¥å™¨ | â­â­ | ~120è¡Œ | ç‚ºç‰¹å®šè³‡æ–™æºå¯¦ç¾æª¢æŸ¥é‚è¼¯ |
| 2 | æ™ºèƒ½å‘Šè­¦éæ¿¾ | â­â­â­ | ~150è¡Œ | æ¸›å°‘å‘Šè­¦ç–²å‹ |
| 3 | å¥åº·è¶¨å‹¢åˆ†æ | â­â­â­ | ~180è¡Œ | é æ¸¬æ€§ç¶­è­· |
| 4 | è‡ªå‹•ä¿®å¾©ç³»çµ± | â­â­â­â­ | ~200è¡Œ | è‡ªå‹•æ¢å¾©æ•…éšœè³‡æ–™æº |
| 5 | å¤šç¶­åº¦å¥åº·è©•åˆ† | â­â­â­â­ | ~180è¡Œ | ç¶œåˆè©•ä¼°è³‡æ–™æºå¥åº· |
| 6 | æ™ºèƒ½å·¡æª¢èª¿åº¦ | â­â­â­â­â­ | ~220è¡Œ | å‹•æ…‹èª¿æ•´æª¢æŸ¥é »ç‡ |

---

## ç¯„ä¾‹ 1: è‡ªå®šç¾©å¥åº·æª¢æŸ¥å™¨ â­â­

### æ¥­å‹™å ´æ™¯
ç‚ºä¸åŒé¡å‹çš„è³‡æ–™æºå¯¦ç¾å°ˆå±¬çš„å¥åº·æª¢æŸ¥é‚è¼¯ï¼Œä¾‹å¦‚è³‡æ–™åº«é€£æ¥æª¢æŸ¥ã€APIç«¯é»æª¢æŸ¥ã€æ–‡ä»¶ç³»çµ±æª¢æŸ¥ç­‰ã€‚

### å¯¦ç¾æ€è·¯
1. å®šç¾©çµ±ä¸€çš„æª¢æŸ¥å™¨ä»‹é¢
2. å¯¦ç¾å„é¡å‹æª¢æŸ¥å™¨
3. æ”¯æŒè‡ªå®šç¾©æª¢æŸ¥åƒæ•¸
4. æä¾›è©³ç´°çš„æª¢æŸ¥çµæœ

### å®Œæ•´ä»£ç¢¼

```python
from abc import ABC, abstractmethod
from typing import Dict, Optional
import requests
import psycopg2
from pathlib import Path

class HealthChecker(ABC):
    """å¥åº·æª¢æŸ¥å™¨åŸºé¡"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.timeout = config.get('timeout', 30)
    
    @abstractmethod
    def check(self) -> Dict:
        """åŸ·è¡Œå¥åº·æª¢æŸ¥"""
        pass
    
    def _create_result(
        self,
        is_healthy: bool,
        message: str,
        metrics: Dict = None
    ) -> Dict:
        """å‰µå»ºæª¢æŸ¥çµæœ"""
        return {
            'is_healthy': is_healthy,
            'message': message,
            'metrics': metrics or {},
            'timestamp': datetime.now().isoformat()
        }

class DatabaseHealthChecker(HealthChecker):
    """è³‡æ–™åº«å¥åº·æª¢æŸ¥å™¨"""
    
    def check(self) -> Dict:
        """æª¢æŸ¥è³‡æ–™åº«é€£æ¥å’Œæ•ˆèƒ½"""
        start_time = time.time()
        
        try:
            # å»ºç«‹é€£æ¥
            conn = psycopg2.connect(
                host=self.config['host'],
                port=self.config.get('port', 5432),
                database=self.config['database'],
                user=self.config['user'],
                password=self.config['password'],
                connect_timeout=self.timeout
            )
            
            cursor = conn.cursor()
            
            # åŸ·è¡Œæ¸¬è©¦æŸ¥è©¢
            cursor.execute("SELECT 1")
            result = cursor.fetchone()
            
            # æª¢æŸ¥é€£æ¥æ•¸
            cursor.execute("""
                SELECT count(*) FROM pg_stat_activity
                WHERE state = 'active'
            """)
            active_connections = cursor.fetchone()[0]
            
            # æª¢æŸ¥è³‡æ–™åº«å¤§å°
            cursor.execute("""
                SELECT pg_database_size(current_database())
            """)
            db_size = cursor.fetchone()[0]
            
            response_time = time.time() - start_time
            
            cursor.close()
            conn.close()
            
            # åˆ¤æ–·å¥åº·ç‹€æ…‹
            is_healthy = (
                result[0] == 1 and
                response_time < 5.0 and
                active_connections < 100
            )
            
            return self._create_result(
                is_healthy=is_healthy,
                message="è³‡æ–™åº«é‹è¡Œæ­£å¸¸" if is_healthy else "è³‡æ–™åº«æ•ˆèƒ½ç•°å¸¸",
                metrics={
                    'response_time': response_time,
                    'active_connections': active_connections,
                    'database_size_mb': db_size / (1024 * 1024)
                }
            )
            
        except Exception as e:
            return self._create_result(
                is_healthy=False,
                message=f"è³‡æ–™åº«æª¢æŸ¥å¤±æ•—: {str(e)}",
                metrics={'error': str(e)}
            )

class APIHealthChecker(HealthChecker):
    """API å¥åº·æª¢æŸ¥å™¨"""
    
    def check(self) -> Dict:
        """æª¢æŸ¥ API ç«¯é»"""
        url = self.config['url']
        method = self.config.get('method', 'GET')
        expected_status = self.config.get('expected_status', 200)
        
        start_time = time.time()
        
        try:
            response = requests.request(
                method=method,
                url=url,
                timeout=self.timeout,
                headers=self.config.get('headers', {}),
                json=self.config.get('payload', None)
            )
            
            response_time = time.time() - start_time
            
            # åˆ¤æ–·å¥åº·ç‹€æ…‹
            is_healthy = (
                response.status_code == expected_status and
                response_time < 2.0
            )
            
            return self._create_result(
                is_healthy=is_healthy,
                message=f"API ç‹€æ…‹: {response.status_code}",
                metrics={
                    'status_code': response.status_code,
                    'response_time': response_time,
                    'content_length': len(response.content)
                }
            )
            
        except requests.Timeout:
            return self._create_result(
                is_healthy=False,
                message="API è«‹æ±‚è¶…æ™‚",
                metrics={'error': 'timeout'}
            )
        except Exception as e:
            return self._create_result(
                is_healthy=False,
                message=f"API æª¢æŸ¥å¤±æ•—: {str(e)}",
                metrics={'error': str(e)}
            )

class FileSystemHealthChecker(HealthChecker):
    """æ–‡ä»¶ç³»çµ±å¥åº·æª¢æŸ¥å™¨"""
    
    def check(self) -> Dict:
        """æª¢æŸ¥æ–‡ä»¶ç³»çµ±ç‹€æ…‹"""
        path = Path(self.config['path'])
        
        try:
            # æª¢æŸ¥è·¯å¾‘æ˜¯å¦å­˜åœ¨
            if not path.exists():
                return self._create_result(
                    is_healthy=False,
                    message=f"è·¯å¾‘ä¸å­˜åœ¨: {path}"
                )
            
            # æª¢æŸ¥ç£ç¢Ÿç©ºé–“
            stat = os.statvfs(path)
            free_space_gb = (stat.f_bavail * stat.f_frsize) / (1024**3)
            total_space_gb = (stat.f_blocks * stat.f_frsize) / (1024**3)
            usage_percent = (1 - stat.f_bavail / stat.f_blocks) * 100
            
            # æª¢æŸ¥è®€å¯«æ¬Šé™
            test_file = path / '.health_check_test'
            try:
                test_file.write_text('test')
                test_file.unlink()
                is_writable = True
            except:
                is_writable = False
            
            # åˆ¤æ–·å¥åº·ç‹€æ…‹
            is_healthy = (
                usage_percent < 90 and
                free_space_gb > 10 and
                is_writable
            )
            
            return self._create_result(
                is_healthy=is_healthy,
                message="æ–‡ä»¶ç³»çµ±æ­£å¸¸" if is_healthy else "æ–‡ä»¶ç³»çµ±ç©ºé–“ä¸è¶³",
                metrics={
                    'free_space_gb': free_space_gb,
                    'total_space_gb': total_space_gb,
                    'usage_percent': usage_percent,
                    'is_writable': is_writable
                }
            )
            
        except Exception as e:
            return self._create_result(
                is_healthy=False,
                message=f"æ–‡ä»¶ç³»çµ±æª¢æŸ¥å¤±æ•—: {str(e)}",
                metrics={'error': str(e)}
            )

# å¥åº·æª¢æŸ¥å™¨å·¥å» 
class HealthCheckerFactory:
    """å¥åº·æª¢æŸ¥å™¨å·¥å» """
    
    _checkers = {
        'database': DatabaseHealthChecker,
        'api': APIHealthChecker,
        'filesystem': FileSystemHealthChecker
    }
    
    @classmethod
    def create(cls, checker_type: str, config: Dict) -> HealthChecker:
        """å‰µå»ºæª¢æŸ¥å™¨"""
        if checker_type not in cls._checkers:
            raise ValueError(f"ä¸æ”¯æŒçš„æª¢æŸ¥å™¨é¡å‹: {checker_type}")
        
        return cls._checkers[checker_type](config)
    
    @classmethod
    def register(cls, checker_type: str, checker_class: type):
        """è¨»å†Šè‡ªå®šç¾©æª¢æŸ¥å™¨"""
        cls._checkers[checker_type] = checker_class
```

### ä½¿ç”¨ç¯„ä¾‹

```python
# 1. è³‡æ–™åº«å¥åº·æª¢æŸ¥
db_config = {
    'host': 'localhost',
    'database': 'mydb',
    'user': 'user',
    'password': 'pass',
    'timeout': 10
}

db_checker = HealthCheckerFactory.create('database', db_config)
result = db_checker.check()

print(f"å¥åº·ç‹€æ…‹: {result['is_healthy']}")
print(f"è¨Šæ¯: {result['message']}")
print(f"éŸ¿æ‡‰æ™‚é–“: {result['metrics'].get('response_time', 0):.3f}ç§’")

# 2. API å¥åº·æª¢æŸ¥
api_config = {
    'url': 'https://api.example.com/health',
    'method': 'GET',
    'timeout': 5
}

api_checker = HealthCheckerFactory.create('api', api_config)
result = api_checker.check()

# 3. è‡ªå®šç¾©æª¢æŸ¥å™¨
class RedisHealthChecker(HealthChecker):
    def check(self) -> Dict:
        import redis
        try:
            r = redis.Redis(
                host=self.config['host'],
                port=self.config.get('port', 6379),
                socket_connect_timeout=self.timeout
            )
            ping = r.ping()
            return self._create_result(
                is_healthy=ping,
                message="Redis é‹è¡Œæ­£å¸¸" if ping else "Redis ç„¡éŸ¿æ‡‰"
            )
        except Exception as e:
            return self._create_result(
                is_healthy=False,
                message=f"Redis æª¢æŸ¥å¤±æ•—: {str(e)}"
            )

# è¨»å†Šè‡ªå®šç¾©æª¢æŸ¥å™¨
HealthCheckerFactory.register('redis', RedisHealthChecker)

# ä½¿ç”¨è‡ªå®šç¾©æª¢æŸ¥å™¨
redis_config = {'host': 'localhost', 'port': 6379}
redis_checker = HealthCheckerFactory.create('redis', redis_config)
result = redis_checker.check()
```

### æ“´å±•å»ºè­°
1. æ·»åŠ æ›´å¤šæª¢æŸ¥å™¨é¡å‹ï¼ˆMongoDBã€Elasticsearch ç­‰ï¼‰
2. å¯¦ç¾æª¢æŸ¥çµæœæŒä¹…åŒ–
3. æ”¯æŒæª¢æŸ¥æ­·å²è¶¨å‹¢åˆ†æ
4. é›†æˆå‘Šè­¦é€šçŸ¥

---

## ç¯„ä¾‹ 2: æ™ºèƒ½å‘Šè­¦éæ¿¾ â­â­â­

### æ¥­å‹™å ´æ™¯
æ¸›å°‘å‘Šè­¦ç–²å‹ï¼Œé€šéæ™ºèƒ½éæ¿¾é¿å…é‡è¤‡å‘Šè­¦ã€çŸ­æ™‚æ³¢å‹•å‘Šè­¦ï¼Œåªç™¼é€çœŸæ­£é‡è¦çš„å‘Šè­¦ã€‚

### å¯¦ç¾æ€è·¯
1. å¯¦ç¾å‘Šè­¦å»é‡æ©Ÿåˆ¶
2. è¨­ç½®å‘Šè­¦æŠ‘åˆ¶çª—å£
3. åŸºæ–¼åš´é‡ç¨‹åº¦åˆ†ç´š
4. æ”¯æŒå‘Šè­¦èšåˆ

### å®Œæ•´ä»£ç¢¼

```python
from collections import defaultdict
from typing import List, Dict
import hashlib

class SmartAlertFilter:
    """æ™ºèƒ½å‘Šè­¦éæ¿¾å™¨"""
    
    def __init__(self):
        # å‘Šè­¦æ­·å²ï¼ˆç”¨æ–¼å»é‡ï¼‰
        self.alert_history = {}
        
        # æŠ‘åˆ¶è¦å‰‡
        self.suppression_rules = {
            'critical': 0,      # é—œéµå‘Šè­¦ä¸æŠ‘åˆ¶
            'high': 300,        # é«˜ç´šå‘Šè­¦5åˆ†é˜å…§å»é‡
            'medium': 900,      # ä¸­ç´šå‘Šè­¦15åˆ†é˜å…§å»é‡
            'low': 3600         # ä½ç´šå‘Šè­¦1å°æ™‚å…§å»é‡
        }
        
        # å‘Šè­¦è¨ˆæ•¸ï¼ˆç”¨æ–¼èšåˆï¼‰
        self.alert_counts = defaultdict(int)
        self.aggregation_threshold = 5
    
    def filter_alert(self, alert: Dict) -> Dict:
        """éæ¿¾å‘Šè­¦"""
        result = {
            'should_send': False,
            'reason': '',
            'alert': alert
        }
        
        # ç”Ÿæˆå‘Šè­¦æŒ‡ç´‹
        fingerprint = self._generate_fingerprint(alert)
        
        # 1. æª¢æŸ¥æ˜¯å¦é‡è¤‡
        if self._is_duplicate(fingerprint, alert):
            result['reason'] = 'é‡è¤‡å‘Šè­¦ï¼ˆæŠ‘åˆ¶ä¸­ï¼‰'
            return result
        
        # 2. æª¢æŸ¥æ˜¯å¦éœ€è¦èšåˆ
        aggregation_result = self._should_aggregate(alert)
        if aggregation_result['should_aggregate']:
            result['reason'] = 'å‘Šè­¦èšåˆä¸­'
            result['aggregated_count'] = aggregation_result['count']
            return result
        
        # 3. é€šéæ‰€æœ‰éæ¿¾å™¨ï¼Œæ‡‰è©²ç™¼é€
        result['should_send'] = True
        result['reason'] = 'æ–°å‘Šè­¦'
        
        # è¨˜éŒ„å‘Šè­¦
        self._record_alert(fingerprint, alert)
        
        return result
    
    def _generate_fingerprint(self, alert: Dict) -> str:
        """ç”Ÿæˆå‘Šè­¦æŒ‡ç´‹"""
        # ä½¿ç”¨é—œéµæ¬„ä½ç”Ÿæˆå”¯ä¸€æ¨™è­˜
        key_fields = [
            alert.get('source', ''),
            alert.get('type', ''),
            alert.get('severity', ''),
            alert.get('message', '')[:100]  # åªå–å‰100å­—ç¬¦
        ]
        
        fingerprint_str = '|'.join(key_fields)
        return hashlib.md5(fingerprint_str.encode()).hexdigest()
    
    def _is_duplicate(self, fingerprint: str, alert: Dict) -> bool:
        """æª¢æŸ¥æ˜¯å¦é‡è¤‡å‘Šè­¦"""
        if fingerprint not in self.alert_history:
            return False
        
        last_alert = self.alert_history[fingerprint]
        time_diff = (
            datetime.now() - last_alert['timestamp']
        ).total_seconds()
        
        # æ ¹æ“šåš´é‡ç¨‹åº¦åˆ¤æ–·æŠ‘åˆ¶æ™‚é–“
        severity = alert.get('severity', 'medium')
        suppression_time = self.suppression_rules.get(severity, 900)
        
        return time_diff < suppression_time
    
    def _should_aggregate(self, alert: Dict) -> Dict:
        """åˆ¤æ–·æ˜¯å¦æ‡‰è©²èšåˆ"""
        # å°ç›¸åŒä¾†æºå’Œé¡å‹çš„å‘Šè­¦é€²è¡Œè¨ˆæ•¸
        agg_key = f"{alert.get('source', '')}:{alert.get('type', '')}"
        self.alert_counts[agg_key] += 1
        
        count = self.alert_counts[agg_key]
        
        if count < self.aggregation_threshold:
            return {
                'should_aggregate': False,
                'count': count
            }
        
        # é”åˆ°èšåˆé–¾å€¼ï¼Œæ¸…é›¶è¨ˆæ•¸å™¨ä¸¦ç™¼é€èšåˆå‘Šè­¦
        if count == self.aggregation_threshold:
            self.alert_counts[agg_key] = 0
            return {
                'should_aggregate': False,  # ç™¼é€èšåˆå‘Šè­¦
                'count': count,
                'is_aggregated': True
            }
        
        return {
            'should_aggregate': True,
            'count': count
        }
    
    def _record_alert(self, fingerprint: str, alert: Dict):
        """è¨˜éŒ„å‘Šè­¦"""
        self.alert_history[fingerprint] = {
            'alert': alert,
            'timestamp': datetime.now()
        }
        
        # æ¸…ç†éæœŸè¨˜éŒ„ï¼ˆä¿ç•™æœ€è¿‘24å°æ™‚ï¼‰
        cutoff_time = datetime.now() - timedelta(hours=24)
        self.alert_history = {
            fp: data
            for fp, data in self.alert_history.items()
            if data['timestamp'] > cutoff_time
        }
```

### ä½¿ç”¨ç¯„ä¾‹

```python
# å‰µå»ºéæ¿¾å™¨
filter = SmartAlertFilter()

# æ¨¡æ“¬å¤šå€‹å‘Šè­¦
alerts = [
    {
        'source': 'db-server-01',
        'type': 'high_cpu',
        'severity': 'medium',
        'message': 'CPU ä½¿ç”¨ç‡ 85%'
    },
    {
        'source': 'db-server-01',
        'type': 'high_cpu',
        'severity': 'medium',
        'message': 'CPU ä½¿ç”¨ç‡ 86%'  # 1åˆ†é˜å¾Œçš„é‡è¤‡å‘Šè­¦
    },
    {
        'source': 'api-server-01',
        'type': 'high_latency',
        'severity': 'critical',
        'message': 'éŸ¿æ‡‰æ™‚é–“è¶…é5ç§’'
    }
]

for alert in alerts:
    result = filter.filter_alert(alert)
    
    if result['should_send']:
        print(f"âœ… ç™¼é€å‘Šè­¦: {alert['message']}")
        print(f"   åŸå› : {result['reason']}")
    else:
        print(f"â¸ï¸  æŠ‘åˆ¶å‘Šè­¦: {alert['message']}")
        print(f"   åŸå› : {result['reason']}")
```

---

## ç¯„ä¾‹ 3: å¥åº·è¶¨å‹¢åˆ†æ â­â­â­

### æ¥­å‹™å ´æ™¯
åˆ†æè³‡æ–™æºå¥åº·åº¦çš„æ­·å²è¶¨å‹¢ï¼Œé æ¸¬æ½›åœ¨å•é¡Œï¼Œå¯¦ç¾é é˜²æ€§ç¶­è­·ã€‚

### å®Œæ•´ä»£ç¢¼

```python
import numpy as np
from scipy import stats

class HealthTrendAnalyzer:
    """å¥åº·è¶¨å‹¢åˆ†æå™¨"""
    
    def __init__(self, window_size=100):
        self.window_size = window_size
        self.health_history = defaultdict(list)
    
    def record_health_check(
        self,
        source_id: str,
        is_healthy: bool,
        metrics: Dict
    ):
        """è¨˜éŒ„å¥åº·æª¢æŸ¥çµæœ"""
        self.health_history[source_id].append({
            'timestamp': datetime.now(),
            'is_healthy': is_healthy,
            'metrics': metrics
        })
        
        # ä¿ç•™æœ€è¿‘çš„è¨˜éŒ„
        if len(self.health_history[source_id]) > self.window_size:
            self.health_history[source_id] = \
                self.health_history[source_id][-self.window_size:]
    
    def analyze_trend(self, source_id: str) -> Dict:
        """åˆ†æå¥åº·è¶¨å‹¢"""
        if source_id not in self.health_history:
            return {'error': 'ç„¡æ­·å²æ•¸æ“š'}
        
        history = self.health_history[source_id]
        
        if len(history) < 10:
            return {'error': 'æ•¸æ“šä¸è¶³ï¼ˆè‡³å°‘éœ€è¦10å€‹æ•¸æ“šé»ï¼‰'}
        
        # è¨ˆç®—å¥åº·ç‡
        health_rate = sum(
            1 for h in history if h['is_healthy']
        ) / len(history)
        
        # åˆ†æéŸ¿æ‡‰æ™‚é–“è¶¨å‹¢
        response_times = [
            h['metrics'].get('response_time', 0)
            for h in history
            if 'response_time' in h['metrics']
        ]
        
        if response_times:
            # ç·šæ€§å›æ­¸åˆ†æè¶¨å‹¢
            x = np.arange(len(response_times))
            y = np.array(response_times)
            slope, intercept, r_value, p_value, std_err = \
                stats.linregress(x, y)
            
            trend = 'increasing' if slope > 0.01 else \
                   ('decreasing' if slope < -0.01 else 'stable')
        else:
            trend = 'unknown'
            slope = 0
        
        # é æ¸¬æœªä¾†å¥åº·ç‹€æ…‹
        prediction = self._predict_health(history)
        
        return {
            'health_rate': health_rate,
            'trend': trend,
            'slope': slope,
            'prediction': prediction,
            'data_points': len(history)
        }
    
    def _predict_health(self, history: List[Dict]) -> Dict:
        """é æ¸¬æœªä¾†å¥åº·ç‹€æ…‹"""
        # ç°¡å–®çš„åŸºæ–¼æœ€è¿‘è¶¨å‹¢çš„é æ¸¬
        recent_checks = history[-10:]
        recent_health_rate = sum(
            1 for h in recent_checks if h['is_healthy']
        ) / len(recent_checks)
        
        if recent_health_rate < 0.5:
            status = 'critical'
            confidence = 0.8
        elif recent_health_rate < 0.7:
            status = 'warning'
            confidence = 0.6
        else:
            status = 'healthy'
            confidence = 0.7
        
        return {
            'status': status,
            'confidence': confidence,
            'recommendation': self._get_recommendation(status)
        }
    
    def _get_recommendation(self, status: str) -> str:
        """ç²å–å»ºè­°"""
        recommendations = {
            'critical': 'å»ºè­°ç«‹å³æª¢æŸ¥è³‡æ–™æºï¼Œå¯èƒ½éœ€è¦ç¶­è­·',
            'warning': 'å»ºè­°å¯†åˆ‡ç›£æ§ï¼Œè€ƒæ…®é é˜²æ€§ç¶­è­·',
            'healthy': 'è³‡æ–™æºç‹€æ…‹è‰¯å¥½ï¼Œç¹¼çºŒç›£æ§'
        }
        return recommendations.get(status, '')
```

---

**æ›´å¤šç¯„ä¾‹è«‹åƒè€ƒå®Œæ•´æ–‡æª”...**

**ç›¸é—œç« ç¯€**:
- [3.11 æ•…éšœæ’æŸ¥æŒ‡å—](ch3-11-æ•…éšœæ’æŸ¥æŒ‡å—.md)
- [â† è¿”å›ç¬¬3ç« é¦–é ](ch3-index.md)

