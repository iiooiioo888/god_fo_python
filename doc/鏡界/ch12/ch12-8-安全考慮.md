# ç¬¬12ç« ï¼šæ•¸æ“šè³ªé‡ç®¡ç†ä¸­å¿ƒ

## 12.8 å®‰å…¨è€ƒæ…®

**[â† è¿”å›ç¬¬12ç« é¦–é ](ch12-index.md)**

---

## ğŸ”’ å®‰å…¨æ¶æ§‹

æ•¸æ“šè³ªé‡ç®¡ç†ä¸­å¿ƒè™•ç†æ•æ„Ÿçš„æ•¸æ“šè³ªé‡ä¿¡æ¯å’Œæ¥­å‹™æ•¸æ“šï¼Œéœ€è¦å…¨æ–¹ä½çš„å®‰å…¨ä¿éšœã€‚

```
å®‰å…¨å±¤æ¬¡
â”œâ”€â”€ 1. æ•¸æ“šå®‰å…¨
â”‚   â”œâ”€â”€ æ•¸æ“šåŠ å¯†
â”‚   â”œâ”€â”€ æ•¸æ“šè„«æ•
â”‚   â””â”€â”€ æ•¸æ“šå‚™ä»½
â”œâ”€â”€ 2. è¨ªå•æ§åˆ¶
â”‚   â”œâ”€â”€ èº«ä»½èªè­‰
â”‚   â”œâ”€â”€ æ¬Šé™ç®¡ç†
â”‚   â””â”€â”€ å¯©è¨ˆæ—¥èªŒ
â”œâ”€â”€ 3. ç¶²çµ¡å®‰å…¨
â”‚   â”œâ”€â”€ å‚³è¼¸åŠ å¯†
â”‚   â”œâ”€â”€ API å®‰å…¨
â”‚   â””â”€â”€ é˜²ç«ç‰†ç­–ç•¥
â””â”€â”€ 4. åˆè¦æ€§
    â”œâ”€â”€ GDPR
    â”œâ”€â”€ æ•¸æ“šä¿è­·æ³•
    â””â”€â”€ è¡Œæ¥­æ¨™æº–
```

---

## 1ï¸âƒ£ æ•¸æ“šå®‰å…¨

### 1.1 æ•¸æ“šåŠ å¯†

#### éœæ…‹æ•¸æ“šåŠ å¯†

```python
# app/security/encryption.py

from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2
import base64
import os

class DataEncryption:
    """æ•¸æ“šåŠ å¯†ç®¡ç†å™¨"""
    
    def __init__(self, master_key: bytes = None):
        """
        åˆå§‹åŒ–åŠ å¯†å™¨
        
        Args:
            master_key: ä¸»å¯†é‘°ï¼ˆæ‡‰å¾å®‰å…¨çš„å¯†é‘°ç®¡ç†ç³»çµ±ç²å–ï¼‰
        """
        self.master_key = master_key or self._generate_key()
        self.cipher = Fernet(self.master_key)
    
    @staticmethod
    def _generate_key() -> bytes:
        """ç”ŸæˆåŠ å¯†å¯†é‘°"""
        return Fernet.generate_key()
    
    @staticmethod
    def derive_key_from_password(password: str, salt: bytes = None) -> tuple:
        """å¾å¯†ç¢¼æ´¾ç”Ÿå¯†é‘°"""
        if salt is None:
            salt = os.urandom(16)
        
        kdf = PBKDF2(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        return key, salt
    
    def encrypt(self, data: str) -> str:
        """åŠ å¯†æ•¸æ“š"""
        encrypted = self.cipher.encrypt(data.encode())
        return base64.urlsafe_b64encode(encrypted).decode()
    
    def decrypt(self, encrypted_data: str) -> str:
        """è§£å¯†æ•¸æ“š"""
        encrypted = base64.urlsafe_b64decode(encrypted_data.encode())
        decrypted = self.cipher.decrypt(encrypted)
        return decrypted.decode()
    
    def encrypt_file(self, input_path: str, output_path: str):
        """åŠ å¯†æ–‡ä»¶"""
        with open(input_path, 'rb') as f:
            data = f.read()
        
        encrypted = self.cipher.encrypt(data)
        
        with open(output_path, 'wb') as f:
            f.write(encrypted)
    
    def decrypt_file(self, input_path: str, output_path: str):
        """è§£å¯†æ–‡ä»¶"""
        with open(input_path, 'rb') as f:
            encrypted = f.read()
        
        decrypted = self.cipher.decrypt(encrypted)
        
        with open(output_path, 'wb') as f:
            f.write(decrypted)


# PostgreSQL é€æ˜æ•¸æ“šåŠ å¯†ï¼ˆTDEï¼‰
# postgresql.conf é…ç½®
ssl = on
ssl_cert_file = 'server.crt'
ssl_key_file = 'server.key'
ssl_ca_file = 'root.crt'

# åˆ—ç´šåŠ å¯†
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- æ’å…¥åŠ å¯†æ•¸æ“š
INSERT INTO users (name, email_encrypted)
VALUES ('John', pgp_sym_encrypt('john@example.com', 'encryption_key'));

-- æŸ¥è©¢è§£å¯†æ•¸æ“š
SELECT name, pgp_sym_decrypt(email_encrypted::bytea, 'encryption_key') as email
FROM users;
```

#### å‚³è¼¸æ•¸æ“šåŠ å¯†

```python
# TLS/SSL é…ç½®
from flask import Flask
import ssl

app = Flask(__name__)

# SSL ä¸Šä¸‹æ–‡
context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
context.load_cert_chain('cert.pem', 'key.pem')

# å¼·åˆ¶ HTTPS
@app.before_request
def before_request():
    if not request.is_secure:
        url = request.url.replace('http://', 'https://', 1)
        return redirect(url, code=301)

if __name__ == '__main__':
    app.run(ssl_context=context, host='0.0.0.0', port=443)
```

### 1.2 æ•¸æ“šè„«æ•

```python
# app/security/masking.py

import hashlib
import re
from typing import Any, Dict

class DataMasking:
    """æ•¸æ“šè„«æ•å™¨"""
    
    @staticmethod
    def mask_email(email: str) -> str:
        """éƒµç®±è„«æ•ï¼šj***@example.com"""
        if not email or '@' not in email:
            return email
        
        local, domain = email.split('@')
        if len(local) <= 1:
            masked_local = local
        else:
            masked_local = local[0] + '***'
        
        return f"{masked_local}@{domain}"
    
    @staticmethod
    def mask_phone(phone: str) -> str:
        """é›»è©±è™Ÿç¢¼è„«æ•ï¼š138****5678"""
        if not phone:
            return phone
        
        digits = re.sub(r'\D', '', phone)
        if len(digits) < 7:
            return phone
        
        return digits[:3] + '****' + digits[-4:]
    
    @staticmethod
    def mask_id_card(id_card: str) -> str:
        """èº«ä»½è­‰è™Ÿè„«æ•ï¼š110***********1234"""
        if not id_card or len(id_card) < 10:
            return id_card
        
        return id_card[:3] + '***********' + id_card[-4:]
    
    @staticmethod
    def mask_credit_card(card_number: str) -> str:
        """ä¿¡ç”¨å¡è™Ÿè„«æ•ï¼š****-****-****-1234"""
        digits = re.sub(r'\D', '', card_number)
        if len(digits) < 4:
            return card_number
        
        return '****-****-****-' + digits[-4:]
    
    @staticmethod
    def mask_name(name: str) -> str:
        """å§“åè„«æ•ï¼šç‹**"""
        if not name or len(name) == 0:
            return name
        
        if len(name) == 1:
            return name
        elif len(name) == 2:
            return name[0] + '*'
        else:
            return name[0] + '*' * (len(name) - 2) + name[-1]
    
    @staticmethod
    def hash_pii(data: str, salt: str = '') -> str:
        """å° PII é€²è¡Œå“ˆå¸Œï¼ˆä¸å¯é€†ï¼‰"""
        return hashlib.sha256(f"{data}{salt}".encode()).hexdigest()
    
    def mask_dict(self, data: Dict[str, Any], 
                  pii_fields: Dict[str, str]) -> Dict[str, Any]:
        """
        æ‰¹é‡è„«æ•å­—å…¸ä¸­çš„ PII å­—æ®µ
        
        Args:
            data: åŸå§‹æ•¸æ“šå­—å…¸
            pii_fields: PII å­—æ®µæ˜ å°„ {field_name: mask_type}
                       mask_type: email, phone, id_card, name, credit_card
        
        Returns:
            è„«æ•å¾Œçš„æ•¸æ“šå­—å…¸
        """
        masked_data = data.copy()
        
        for field, mask_type in pii_fields.items():
            if field not in masked_data:
                continue
            
            value = masked_data[field]
            
            if mask_type == 'email':
                masked_data[field] = self.mask_email(value)
            elif mask_type == 'phone':
                masked_data[field] = self.mask_phone(value)
            elif mask_type == 'id_card':
                masked_data[field] = self.mask_id_card(value)
            elif mask_type == 'name':
                masked_data[field] = self.mask_name(value)
            elif mask_type == 'credit_card':
                masked_data[field] = self.mask_credit_card(value)
            elif mask_type == 'hash':
                masked_data[field] = self.hash_pii(value)
        
        return masked_data


# ä½¿ç”¨ç¤ºä¾‹
masker = DataMasking()

original_data = {
    'name': 'ç‹å°æ˜',
    'email': 'wangxiaoming@example.com',
    'phone': '13812345678',
    'id_card': '110101199001011234'
}

pii_fields = {
    'name': 'name',
    'email': 'email',
    'phone': 'phone',
    'id_card': 'id_card'
}

masked_data = masker.mask_dict(original_data, pii_fields)
# çµæœï¼š
# {
#     'name': 'ç‹**',
#     'email': 'w***@example.com',
#     'phone': '138****5678',
#     'id_card': '110***********1234'
# }
```

### 1.3 æ•¸æ“šå‚™ä»½èˆ‡æ¢å¾©

```python
# app/security/backup.py

import subprocess
from datetime import datetime
import boto3
import logging

logger = logging.getLogger(__name__)

class BackupManager:
    """å‚™ä»½ç®¡ç†å™¨"""
    
    def __init__(self, config: dict):
        self.config = config
        self.s3_client = boto3.client('s3')
    
    def backup_database(self, database: str, output_path: str = None):
        """å‚™ä»½æ•¸æ“šåº«"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        output_path = output_path or f"/backups/{database}_{timestamp}.sql.gz"
        
        # ä½¿ç”¨ pg_dump å‚™ä»½
        cmd = [
            'pg_dump',
            '-h', self.config['db_host'],
            '-U', self.config['db_user'],
            '-d', database,
            '-F', 'c',  # è‡ªå®šç¾©æ ¼å¼ï¼ˆæ”¯æŒä¸¦è¡Œæ¢å¾©ï¼‰
            '-f', output_path,
            '--no-owner',
            '--no-acl',
            '-Z', '9'  # æœ€å¤§å£“ç¸®
        ]
        
        try:
            subprocess.run(cmd, check=True, env={
                'PGPASSWORD': self.config['db_password']
            })
            
            logger.info(f"Database backup created: {output_path}")
            
            # ä¸Šå‚³åˆ° S3
            self.upload_to_s3(output_path, database)
            
            return output_path
        
        except subprocess.CalledProcessError as e:
            logger.error(f"Backup failed: {e}")
            raise
    
    def upload_to_s3(self, file_path: str, database: str):
        """ä¸Šå‚³å‚™ä»½åˆ° S3"""
        bucket = self.config['backup_bucket']
        key = f"{database}/{os.path.basename(file_path)}"
        
        try:
            self.s3_client.upload_file(
                file_path,
                bucket,
                key,
                ExtraArgs={
                    'StorageClass': 'GLACIER',  # ä½¿ç”¨å†·å­˜å„²é™ä½æˆæœ¬
                    'ServerSideEncryption': 'AES256'  # æœå‹™ç«¯åŠ å¯†
                }
            )
            
            logger.info(f"Backup uploaded to S3: s3://{bucket}/{key}")
        
        except Exception as e:
            logger.error(f"S3 upload failed: {e}")
            raise
    
    def restore_database(self, backup_file: str, database: str):
        """æ¢å¾©æ•¸æ“šåº«"""
        cmd = [
            'pg_restore',
            '-h', self.config['db_host'],
            '-U', self.config['db_user'],
            '-d', database,
            '--clean',  # æ¸…ç†ç¾æœ‰å°è±¡
            '--if-exists',
            '-j', '4',  # ä¸¦è¡Œæ¢å¾©ï¼ˆ4å€‹jobï¼‰
            backup_file
        ]
        
        try:
            subprocess.run(cmd, check=True, env={
                'PGPASSWORD': self.config['db_password']
            })
            
            logger.info(f"Database restored from: {backup_file}")
        
        except subprocess.CalledProcessError as e:
            logger.error(f"Restore failed: {e}")
            raise
    
    def list_backups(self, database: str) -> list:
        """åˆ—å‡ºæ‰€æœ‰å‚™ä»½"""
        bucket = self.config['backup_bucket']
        prefix = f"{database}/"
        
        response = self.s3_client.list_objects_v2(
            Bucket=bucket,
            Prefix=prefix
        )
        
        backups = []
        for obj in response.get('Contents', []):
            backups.append({
                'key': obj['Key'],
                'size': obj['Size'],
                'last_modified': obj['LastModified']
            })
        
        return backups
    
    def cleanup_old_backups(self, database: str, keep_days: int = 30):
        """æ¸…ç†èˆŠå‚™ä»½"""
        from datetime import timedelta
        
        cutoff_date = datetime.now() - timedelta(days=keep_days)
        backups = self.list_backups(database)
        
        deleted_count = 0
        for backup in backups:
            if backup['last_modified'] < cutoff_date:
                self.s3_client.delete_object(
                    Bucket=self.config['backup_bucket'],
                    Key=backup['key']
                )
                deleted_count += 1
                logger.info(f"Deleted old backup: {backup['key']}")
        
        logger.info(f"Cleaned up {deleted_count} old backups")
```

---

## 2ï¸âƒ£ è¨ªå•æ§åˆ¶

### 2.1 èº«ä»½èªè­‰

```python
# app/security/authentication.py

from flask import Flask, request, jsonify
from flask_jwt_extended import (
    JWTManager, create_access_token, create_refresh_token,
    jwt_required, get_jwt_identity, get_jwt
)
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import timedelta
import redis

app = Flask(__name__)

# JWT é…ç½®
app.config['JWT_SECRET_KEY'] = 'your-secret-key'  # å¾ç’°å¢ƒè®Šé‡è®€å–
app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(hours=1)
app.config['JWT_REFRESH_TOKEN_EXPIRES'] = timedelta(days=30)
app.config['JWT_ALGORITHM'] = 'HS256'

jwt = JWTManager(app)

# Redis ç”¨æ–¼é»‘åå–®
redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)


class AuthService:
    """èªè­‰æœå‹™"""
    
    @staticmethod
    def register_user(username: str, password: str, email: str) -> dict:
        """ç”¨æˆ¶è¨»å†Š"""
        # æª¢æŸ¥ç”¨æˆ¶æ˜¯å¦å­˜åœ¨
        if User.query.filter_by(username=username).first():
            raise ValueError("Username already exists")
        
        # å¯†ç¢¼å“ˆå¸Œ
        password_hash = generate_password_hash(
            password,
            method='pbkdf2:sha256',
            salt_length=16
        )
        
        # å‰µå»ºç”¨æˆ¶
        user = User(
            username=username,
            password_hash=password_hash,
            email=email
        )
        
        db.session.add(user)
        db.session.commit()
        
        return {'user_id': user.id, 'username': user.username}
    
    @staticmethod
    def login(username: str, password: str) -> dict:
        """ç”¨æˆ¶ç™»éŒ„"""
        user = User.query.filter_by(username=username).first()
        
        if not user or not check_password_hash(user.password_hash, password):
            raise ValueError("Invalid username or password")
        
        # ç”Ÿæˆ Token
        access_token = create_access_token(
            identity=user.id,
            additional_claims={
                'username': user.username,
                'roles': [role.name for role in user.roles]
            }
        )
        
        refresh_token = create_refresh_token(identity=user.id)
        
        # è¨˜éŒ„ç™»éŒ„
        LoginLog.create(user_id=user.id, ip=request.remote_addr)
        
        return {
            'access_token': access_token,
            'refresh_token': refresh_token,
            'user': {
                'id': user.id,
                'username': user.username,
                'email': user.email
            }
        }
    
    @staticmethod
    def logout(jti: str):
        """ç”¨æˆ¶ç™»å‡ºï¼ˆå°‡ Token åŠ å…¥é»‘åå–®ï¼‰"""
        # Token åŠ å…¥ Redis é»‘åå–®
        redis_client.setex(
            f"blacklist:{jti}",
            timedelta(hours=1),
            'true'
        )


# JWT å›èª¿
@jwt.token_in_blocklist_loader
def check_if_token_revoked(jwt_header, jwt_payload):
    """æª¢æŸ¥ Token æ˜¯å¦åœ¨é»‘åå–®ä¸­"""
    jti = jwt_payload["jti"]
    return redis_client.get(f"blacklist:{jti}") is not None


# API ç«¯é»
@app.route('/auth/login', methods=['POST'])
def login():
    """ç™»éŒ„ç«¯é»"""
    data = request.get_json()
    
    try:
        result = AuthService.login(
            data['username'],
            data['password']
        )
        return jsonify(result), 200
    
    except ValueError as e:
        return jsonify({'error': str(e)}), 401


@app.route('/auth/logout', methods=['POST'])
@jwt_required()
def logout():
    """ç™»å‡ºç«¯é»"""
    jti = get_jwt()["jti"]
    AuthService.logout(jti)
    return jsonify({'message': 'Successfully logged out'}), 200


@app.route('/auth/refresh', methods=['POST'])
@jwt_required(refresh=True)
def refresh():
    """åˆ·æ–° Token"""
    current_user = get_jwt_identity()
    access_token = create_access_token(identity=current_user)
    return jsonify({'access_token': access_token}), 200


# ä¿è­·çš„ç«¯é»ç¤ºä¾‹
@app.route('/api/quality/checks', methods=['GET'])
@jwt_required()
def get_quality_checks():
    """ç²å–è³ªé‡æª¢æŸ¥ï¼ˆéœ€è¦èªè­‰ï¼‰"""
    current_user_id = get_jwt_identity()
    # ... æ¥­å‹™é‚è¼¯
    return jsonify({'data': []}), 200
```

### 2.2 æ¬Šé™ç®¡ç†ï¼ˆRBACï¼‰

```python
# app/security/authorization.py

from enum import Enum
from functools import wraps
from flask import jsonify
from flask_jwt_extended import get_jwt

class Permission(Enum):
    """æ¬Šé™æšèˆ‰"""
    # è³ªé‡æª¢æŸ¥
    QUALITY_CHECK_VIEW = "quality:check:view"
    QUALITY_CHECK_CREATE = "quality:check:create"
    QUALITY_CHECK_DELETE = "quality:check:delete"
    
    # æ•¸æ“šæ¸…æ´—
    CLEANING_EXECUTE = "cleaning:execute"
    CLEANING_CONFIG = "cleaning:config"
    
    # è¦å‰‡ç®¡ç†
    RULE_VIEW = "rule:view"
    RULE_CREATE = "rule:create"
    RULE_UPDATE = "rule:update"
    RULE_DELETE = "rule:delete"
    
    # å ±å‘Š
    REPORT_VIEW = "report:view"
    REPORT_GENERATE = "report:generate"
    
    # ç³»çµ±ç®¡ç†
    ADMIN_USER_MANAGE = "admin:user:manage"
    ADMIN_SYSTEM_CONFIG = "admin:system:config"


class Role:
    """è§’è‰²å®šç¾©"""
    
    VIEWER = {
        'name': 'viewer',
        'permissions': [
            Permission.QUALITY_CHECK_VIEW,
            Permission.RULE_VIEW,
            Permission.REPORT_VIEW
        ]
    }
    
    OPERATOR = {
        'name': 'operator',
        'permissions': [
            Permission.QUALITY_CHECK_VIEW,
            Permission.QUALITY_CHECK_CREATE,
            Permission.CLEANING_EXECUTE,
            Permission.RULE_VIEW,
            Permission.REPORT_VIEW,
            Permission.REPORT_GENERATE
        ]
    }
    
    ADMIN = {
        'name': 'admin',
        'permissions': [
            # æ‰€æœ‰æ¬Šé™
            *list(Permission)
        ]
    }


def require_permission(permission: Permission):
    """æ¬Šé™æª¢æŸ¥è£é£¾å™¨"""
    def decorator(fn):
        @wraps(fn)
        @jwt_required()
        def wrapper(*args, **kwargs):
            claims = get_jwt()
            user_roles = claims.get('roles', [])
            
            # ç²å–ç”¨æˆ¶çš„æ‰€æœ‰æ¬Šé™
            user_permissions = set()
            for role_name in user_roles:
                role = getattr(Role, role_name.upper(), None)
                if role:
                    user_permissions.update(
                        p.value for p in role['permissions']
                    )
            
            # æª¢æŸ¥æ¬Šé™
            if permission.value not in user_permissions:
                return jsonify({
                    'error': 'Insufficient permissions'
                }), 403
            
            return fn(*args, **kwargs)
        
        return wrapper
    return decorator


# ä½¿ç”¨ç¤ºä¾‹
@app.route('/api/rules', methods=['POST'])
@require_permission(Permission.RULE_CREATE)
def create_rule():
    """å‰µå»ºè¦å‰‡ï¼ˆéœ€è¦ RULE_CREATE æ¬Šé™ï¼‰"""
    # ... æ¥­å‹™é‚è¼¯
    return jsonify({'message': 'Rule created'}), 201


@app.route('/api/admin/users', methods=['GET'])
@require_permission(Permission.ADMIN_USER_MANAGE)
def list_users():
    """åˆ—å‡ºç”¨æˆ¶ï¼ˆéœ€è¦ ADMIN_USER_MANAGE æ¬Šé™ï¼‰"""
    # ... æ¥­å‹™é‚è¼¯
    return jsonify({'users': []}), 200
```

### 2.3 å¯©è¨ˆæ—¥èªŒ

```python
# app/security/audit.py

from datetime import datetime
from flask import request, g
import json

class AuditLogger:
    """å¯©è¨ˆæ—¥èªŒè¨˜éŒ„å™¨"""
    
    @staticmethod
    def log_action(action: str, resource: str, details: dict = None):
        """è¨˜éŒ„å¯©è¨ˆæ—¥èªŒ"""
        log_entry = {
            'timestamp': datetime.utcnow(),
            'user_id': g.get('user_id'),
            'username': g.get('username'),
            'action': action,  # CREATE, READ, UPDATE, DELETE
            'resource': resource,
            'resource_id': details.get('resource_id') if details else None,
            'ip_address': request.remote_addr,
            'user_agent': request.headers.get('User-Agent'),
            'request_method': request.method,
            'request_path': request.path,
            'status': details.get('status', 'success') if details else 'success',
            'details': json.dumps(details) if details else None
        }
        
        # å¯«å…¥æ•¸æ“šåº«
        audit_log = AuditLog(**log_entry)
        db.session.add(audit_log)
        db.session.commit()
        
        # åŒæ™‚å¯«å…¥æ—¥èªŒæ–‡ä»¶
        logger.info(f"AUDIT: {json.dumps(log_entry, default=str)}")


# æ•¸æ“šæ¨¡å‹
class AuditLog(db.Model):
    """å¯©è¨ˆæ—¥èªŒè¡¨"""
    __tablename__ = 'audit_logs'
    
    id = db.Column(db.BigInteger, primary_key=True)
    timestamp = db.Column(db.DateTime, nullable=False, index=True)
    user_id = db.Column(db.BigInteger, index=True)
    username = db.Column(db.String(100))
    action = db.Column(db.String(20), nullable=False, index=True)
    resource = db.Column(db.String(100), nullable=False, index=True)
    resource_id = db.Column(db.String(100), index=True)
    ip_address = db.Column(db.String(45))
    user_agent = db.Column(db.Text)
    request_method = db.Column(db.String(10))
    request_path = db.Column(db.String(500))
    status = db.Column(db.String(20))
    details = db.Column(db.JSON)


# å¯©è¨ˆè£é£¾å™¨
def audited(resource: str):
    """å¯©è¨ˆè£é£¾å™¨"""
    def decorator(fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            # åŸ·è¡ŒåŸå‡½æ•¸
            result = fn(*args, **kwargs)
            
            # è¨˜éŒ„å¯©è¨ˆæ—¥èªŒ
            action = {
                'GET': 'READ',
                'POST': 'CREATE',
                'PUT': 'UPDATE',
                'PATCH': 'UPDATE',
                'DELETE': 'DELETE'
            }.get(request.method, 'UNKNOWN')
            
            AuditLogger.log_action(
                action=action,
                resource=resource,
                details={
                    'resource_id': kwargs.get('id'),
                    'status': 'success'
                }
            )
            
            return result
        
        return wrapper
    return decorator


# ä½¿ç”¨ç¤ºä¾‹
@app.route('/api/rules/<int:id>', methods=['DELETE'])
@jwt_required()
@require_permission(Permission.RULE_DELETE)
@audited('quality_rule')
def delete_rule(id):
    """åˆªé™¤è¦å‰‡ï¼ˆå¸¶å¯©è¨ˆï¼‰"""
    rule = QualityRule.query.get_or_404(id)
    db.session.delete(rule)
    db.session.commit()
    return jsonify({'message': 'Rule deleted'}), 200
```

---

## 3ï¸âƒ£ ç¶²çµ¡å®‰å…¨

### 3.1 API å®‰å…¨

```python
# app/security/api_security.py

from flask import Flask, request, jsonify
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from flask_cors import CORS
import hashlib
import hmac
import time

app = Flask(__name__)

# 1. CORS é…ç½®
CORS(app, resources={
    r"/api/*": {
        "origins": ["https://trusted-domain.com"],
        "methods": ["GET", "POST", "PUT", "DELETE"],
        "allow_headers": ["Content-Type", "Authorization"],
        "max_age": 3600
    }
})

# 2. é€Ÿç‡é™åˆ¶
limiter = Limiter(
    app=app,
    key_func=get_remote_address,
    default_limits=["1000 per hour", "100 per minute"],
    storage_uri="redis://localhost:6379"
)

@app.route('/api/quality/checks', methods=['POST'])
@limiter.limit("10 per minute")  # æ¯åˆ†é˜æœ€å¤š 10 æ¬¡
def create_quality_check():
    """å‰µå»ºè³ªé‡æª¢æŸ¥ï¼ˆé™æµï¼‰"""
    # ... æ¥­å‹™é‚è¼¯
    return jsonify({'message': 'Check created'}), 201


# 3. è«‹æ±‚ç°½åé©—è­‰
class RequestSignatureValidator:
    """è«‹æ±‚ç°½åé©—è­‰å™¨"""
    
    @staticmethod
    def generate_signature(secret: str, data: dict, timestamp: str) -> str:
        """ç”Ÿæˆè«‹æ±‚ç°½å"""
        # æŒ‰éµæ’åºåƒæ•¸
        sorted_data = sorted(data.items())
        
        # æ§‹å»ºç°½åå­—ç¬¦ä¸²
        sign_string = f"{timestamp}{''.join(f'{k}={v}' for k, v in sorted_data)}"
        
        # HMAC-SHA256 ç°½å
        signature = hmac.new(
            secret.encode(),
            sign_string.encode(),
            hashlib.sha256
        ).hexdigest()
        
        return signature
    
    @staticmethod
    def validate_signature(secret: str, data: dict, 
                          timestamp: str, signature: str) -> bool:
        """é©—è­‰è«‹æ±‚ç°½å"""
        # æª¢æŸ¥æ™‚é–“æˆ³ï¼ˆé˜²é‡æ”¾æ”»æ“Šï¼‰
        current_time = int(time.time())
        request_time = int(timestamp)
        
        if abs(current_time - request_time) > 300:  # 5åˆ†é˜å…§æœ‰æ•ˆ
            return False
        
        # é©—è­‰ç°½å
        expected_signature = RequestSignatureValidator.generate_signature(
            secret, data, timestamp
        )
        
        return hmac.compare_digest(signature, expected_signature)


# ç°½åé©—è­‰è£é£¾å™¨
def require_signature(fn):
    """è«‹æ±‚ç°½åé©—è­‰è£é£¾å™¨"""
    @wraps(fn)
    def wrapper(*args, **kwargs):
        timestamp = request.headers.get('X-Timestamp')
        signature = request.headers.get('X-Signature')
        api_key = request.headers.get('X-API-Key')
        
        if not all([timestamp, signature, api_key]):
            return jsonify({'error': 'Missing signature headers'}), 401
        
        # ç²å– API å¯†é‘°çš„ secret
        secret = get_api_secret(api_key)
        if not secret:
            return jsonify({'error': 'Invalid API key'}), 401
        
        # é©—è­‰ç°½å
        data = request.get_json() or {}
        if not RequestSignatureValidator.validate_signature(
            secret, data, timestamp, signature
        ):
            return jsonify({'error': 'Invalid signature'}), 401
        
        return fn(*args, **kwargs)
    
    return wrapper


# 4. è¼¸å…¥é©—è­‰
from marshmallow import Schema, fields, validate, ValidationError

class QualityCheckSchema(Schema):
    """è³ªé‡æª¢æŸ¥è¼¸å…¥é©—è­‰"""
    data_source = fields.Str(required=True, validate=validate.Length(min=1, max=200))
    table_name = fields.Str(validate=validate.Length(max=200))
    check_type = fields.Str(
        required=True,
        validate=validate.OneOf(['full', 'incremental', 'sample'])
    )
    rules = fields.List(fields.Str(), required=True)


@app.route('/api/quality/checks', methods=['POST'])
@jwt_required()
def create_quality_check_validated():
    """å‰µå»ºè³ªé‡æª¢æŸ¥ï¼ˆå¸¶è¼¸å…¥é©—è­‰ï¼‰"""
    schema = QualityCheckSchema()
    
    try:
        # é©—è­‰è¼¸å…¥
        data = schema.load(request.get_json())
    except ValidationError as err:
        return jsonify({'errors': err.messages}), 400
    
    # ... æ¥­å‹™é‚è¼¯
    return jsonify({'message': 'Check created'}), 201


# 5. SQL æ³¨å…¥é˜²è­·
from sqlalchemy import text

# éŒ¯èª¤ç¤ºä¾‹ï¼ˆå®¹æ˜“ SQL æ³¨å…¥ï¼‰
# query = f"SELECT * FROM users WHERE username = '{username}'"
# db.execute(query)

# æ­£ç¢ºç¤ºä¾‹ï¼ˆä½¿ç”¨åƒæ•¸åŒ–æŸ¥è©¢ï¼‰
def safe_query(username: str):
    """å®‰å…¨çš„æŸ¥è©¢"""
    query = text("SELECT * FROM users WHERE username = :username")
    result = db.execute(query, {"username": username})
    return result.fetchall()
```

---

## 4ï¸âƒ£ åˆè¦æ€§

### 4.1 GDPR åˆè¦

```python
# app/security/gdpr.py

class GDPRCompliance:
    """GDPR åˆè¦å·¥å…·"""
    
    @staticmethod
    def export_user_data(user_id: int) -> dict:
        """
        å°å‡ºç”¨æˆ¶æ•¸æ“šï¼ˆGDPR æ•¸æ“šå¯æ”œå¸¶æ¬Šï¼‰
        
        Returns:
            ç”¨æˆ¶çš„æ‰€æœ‰å€‹äººæ•¸æ“š
        """
        user = User.query.get(user_id)
        
        if not user:
            raise ValueError("User not found")
        
        # æ”¶é›†æ‰€æœ‰å€‹äººæ•¸æ“š
        user_data = {
            'personal_info': {
                'username': user.username,
                'email': user.email,
                'created_at': user.created_at.isoformat(),
                'last_login': user.last_login.isoformat() if user.last_login else None
            },
            'quality_checks': [
                {
                    'check_id': check.check_id,
                    'data_source': check.data_source,
                    'quality_score': float(check.quality_score),
                    'created_at': check.started_at.isoformat()
                }
                for check in user.quality_checks
            ],
            'audit_logs': [
                {
                    'action': log.action,
                    'resource': log.resource,
                    'timestamp': log.timestamp.isoformat()
                }
                for log in user.audit_logs
            ]
        }
        
        return user_data
    
    @staticmethod
    def delete_user_data(user_id: int, reason: str = None):
        """
        åˆªé™¤ç”¨æˆ¶æ•¸æ“šï¼ˆGDPR è¢«éºå¿˜æ¬Šï¼‰
        
        Args:
            user_id: ç”¨æˆ¶ ID
            reason: åˆªé™¤åŸå› 
        """
        user = User.query.get(user_id)
        
        if not user:
            raise ValueError("User not found")
        
        # 1. è¨˜éŒ„åˆªé™¤è«‹æ±‚
        deletion_request = DataDeletionRequest(
            user_id=user_id,
            username=user.username,
            requested_at=datetime.utcnow(),
            reason=reason,
            status='processing'
        )
        db.session.add(deletion_request)
        db.session.commit()
        
        # 2. åŒ¿ååŒ–æˆ–åˆªé™¤å€‹äººæ•¸æ“š
        try:
            # åŒ¿ååŒ–å¯©è¨ˆæ—¥èªŒ
            AuditLog.query.filter_by(user_id=user_id).update({
                'username': f'deleted_user_{user_id}',
                'user_id': None
            })
            
            # åˆªé™¤å€‹äººä¿¡æ¯
            user.email = None
            user.phone = None
            user.is_deleted = True
            user.deleted_at = datetime.utcnow()
            
            # æˆ–å®Œå…¨åˆªé™¤ç”¨æˆ¶è¨˜éŒ„
            # db.session.delete(user)
            
            db.session.commit()
            
            # æ›´æ–°åˆªé™¤è«‹æ±‚ç‹€æ…‹
            deletion_request.status = 'completed'
            deletion_request.completed_at = datetime.utcnow()
            db.session.commit()
        
        except Exception as e:
            deletion_request.status = 'failed'
            deletion_request.error_message = str(e)
            db.session.commit()
            raise
    
    @staticmethod
    def rectify_user_data(user_id: int, updates: dict):
        """
        æ›´æ­£ç”¨æˆ¶æ•¸æ“šï¼ˆGDPR æ›´æ­£æ¬Šï¼‰
        
        Args:
            user_id: ç”¨æˆ¶ ID
            updates: è¦æ›´æ–°çš„æ•¸æ“š
        """
        user = User.query.get(user_id)
        
        if not user:
            raise ValueError("User not found")
        
        # è¨˜éŒ„æ›´æ”¹å‰çš„æ•¸æ“š
        old_data = {
            'email': user.email,
            'phone': user.phone,
            # ... å…¶ä»–å­—æ®µ
        }
        
        # æ‡‰ç”¨æ›´æ–°
        for key, value in updates.items():
            if hasattr(user, key):
                setattr(user, key, value)
        
        db.session.commit()
        
        # è¨˜éŒ„æ•¸æ“šæ›´æ­£æ—¥èªŒ
        DataRectificationLog.create(
            user_id=user_id,
            old_data=old_data,
            new_data=updates,
            timestamp=datetime.utcnow()
        )
```

---

## ğŸ“‘ ç›¸é—œç« ç¯€

| å‰åº | ç•¶å‰ | å¾ŒçºŒ |
|-----|------|------|
| [12.7 æ•ˆèƒ½å„ªåŒ–ç­–ç•¥](ch12-7-æ•ˆèƒ½å„ªåŒ–ç­–ç•¥.md) | **12.8 å®‰å…¨è€ƒæ…®** | [12.9 èˆ‡å…¶ä»–æ¨¡çµ„çš„äº¤äº’](ch12-9-èˆ‡å…¶ä»–æ¨¡çµ„çš„äº¤äº’.md) |

**å¿«é€Ÿéˆæ¥ï¼š**
- [12.1 æ¨¡çµ„æ¦‚è¿°](ch12-1-æ¨¡çµ„æ¦‚è¿°.md)
- [12.7 æ•ˆèƒ½å„ªåŒ–ç­–ç•¥](ch12-7-æ•ˆèƒ½å„ªåŒ–ç­–ç•¥.md)
- [12.9 èˆ‡å…¶ä»–æ¨¡çµ„çš„äº¤äº’](ch12-9-èˆ‡å…¶ä»–æ¨¡çµ„çš„äº¤äº’.md)
- [â† è¿”å›ç¬¬12ç« é¦–é ](ch12-index.md)

---

**æœ€å¾Œæ›´æ–°**: 2025-10-31  
**ç‰ˆæœ¬**: 1.0

