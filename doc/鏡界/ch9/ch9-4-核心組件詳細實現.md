**[â† è¿”å›ç¬¬9ç« é¦–é ](ch9-index.md)**

---

### 9.4 æ ¸å¿ƒçµ„ä»¶è©³ç´°å¯¦ç¾

#### 9.4.1 APIç¶²é—œå¯¦ç¾

```python
from typing import Dict, List, Optional
import asyncio
import logging
from datetime import datetime

class APIGateway:
    """APIç¶²é—œæ ¸å¿ƒå¯¦ç¾"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.rate_limiters = {}
        self.circuit_breakers = {}
        self.middleware_stack = []
    
    async def process_request(self, request) -> Dict:
        """è™•ç†è«‹æ±‚çš„ä¸»æµç¨‹"""
        try:
            # 1. é©—è­‰è«‹æ±‚
            self._validate_request(request)
            
            # 2. èªè­‰
            user = await self._authenticate(request)
            
            # 3. æˆæ¬Š
            self._authorize(user, request)
            
            # 4. é€Ÿç‡é™åˆ¶
            await self._apply_rate_limit(user)
            
            # 5. è½‰ç™¼åˆ°å¾Œç«¯æœå‹™
            response = await self._forward_request(request, user)
            
            # 6. æ‡‰ç”¨ä¸­é–“ä»¶
            response = await self._apply_middleware(response)
            
            return response
            
        except Exception as e:
            self.logger.error(f"Request processing error: {e}")
            return {"error": str(e), "status": 500}
    
    def _validate_request(self, request):
        """é©—è­‰è«‹æ±‚æ ¼å¼"""
        if not request.method or not request.path:
            raise ValueError("Invalid request format")
    
    async def _authenticate(self, request):
        """èªè­‰ç”¨æˆ¶"""
        token = request.headers.get("Authorization", "").replace("Bearer ", "")
        if not token:
            raise ValueError("Missing authentication token")
        # é©—è­‰tokené‚è¼¯...
        return {"user_id": "user123", "roles": ["user"]}
    
    def _authorize(self, user: Dict, request):
        """æˆæ¬Šæª¢æŸ¥"""
        required_role = self._get_required_role(request.path)
        if required_role not in user.get("roles", []):
            raise PermissionError(f"Insufficient permissions for {request.path}")
    
    async def _apply_rate_limit(self, user: Dict):
        """æ‡‰ç”¨é€Ÿç‡é™åˆ¶"""
        user_id = user["user_id"]
        if user_id not in self.rate_limiters:
            self.rate_limiters[user_id] = {"count": 0, "reset_time": datetime.now()}
        
        limiter = self.rate_limiters[user_id]
        if (datetime.now() - limiter["reset_time"]).seconds > 60:
            limiter["count"] = 0
            limiter["reset_time"] = datetime.now()
        
        limiter["count"] += 1
        if limiter["count"] > self.config.get("rate_limit", 1000):
            raise ValueError("Rate limit exceeded")
    
    async def _forward_request(self, request, user):
        """è½‰ç™¼è«‹æ±‚åˆ°å¾Œç«¯æœå‹™"""
        service = self._route_request(request.path)
        # æ·»åŠ ç”¨æˆ¶ä¿¡æ¯åˆ°è«‹æ±‚
        request.headers["X-User-ID"] = user["user_id"]
        # è½‰ç™¼åˆ°æœå‹™...
        return {"status": 200, "data": "Response from service"}
    
    async def _apply_middleware(self, response):
        """æ‡‰ç”¨ä¸­é–“ä»¶"""
        for middleware in self.middleware_stack:
            response = await middleware(response)
        return response
    
    def _route_request(self, path: str) -> str:
        """è·¯ç”±è«‹æ±‚åˆ°ä¸åŒæœå‹™"""
        routes = {
            "/api/v1/data-sources": "ch1-service",
            "/api/v1/fingerprint": "ch2-service",
            "/api/v1/monitoring": "ch3-service",
            # ... æ›´å¤šè·¯ç”±
        }
        for route_path, service in routes.items():
            if path.startswith(route_path):
                return service
        raise ValueError(f"No route found for {path}")
    
    def _get_required_role(self, path: str) -> str:
        """ç²å–è·¯å¾‘æ‰€éœ€çš„è§’è‰²"""
        if path.startswith("/api/v1/admin"):
            return "admin"
        if path.startswith("/api/v1/"):
            return "user"
        return "public"
```

#### 9.4.2 æœå‹™ç¶²æ ¼å¯¦ç¾

```python
class ServiceMesh:
    """æœå‹™ç¶²æ ¼å¯¦ç¾"""
    
    def __init__(self):
        self.services = {}
        self.lb = LoadBalancer()
        self.circuit_breaker = CircuitBreaker()
    
    def register_service(self, name: str, instances: List[str]):
        """è¨»å†Šæœå‹™"""
        self.services[name] = instances
    
    async def call_service(self, service_name: str, request: Dict):
        """èª¿ç”¨æœå‹™"""
        if service_name not in self.services:
            raise ValueError(f"Service {service_name} not found")
        
        instances = self.services[service_name]
        instance = self.lb.select(instances)
        
        try:
            return await self.circuit_breaker.call(instance, request)
        except Exception as e:
            return {"error": str(e), "status": 503}
```

#### 9.4.3 è² è¼‰å‡è¡¡å¯¦ç¾

```python
class LoadBalancer:
    """è² è¼‰å‡è¡¡å™¨"""
    
    def __init__(self):
        self.current_index = 0
    
    def select(self, instances: List[str]) -> str:
        """è¼ªè©¢é¸æ“‡å¯¦ä¾‹"""
        if not instances:
            raise ValueError("No available instances")
        
        selected = instances[self.current_index % len(instances)]
        self.current_index += 1
        return selected
```

---

**æ³¨æ„**: æœ¬ç« ç¯€çš„CI/CDç›¸é—œå®Œæ•´å…§å®¹å·²ç§»è‡³ [9.14 æŒçºŒæ•´åˆèˆ‡æŒçºŒéƒ¨ç½²](ch9-14-æŒçºŒæ•´åˆèˆ‡æŒçºŒéƒ¨ç½².md)

## ğŸ“‘ ç›¸é—œç« ç¯€

|| å‰åº | ç•¶å‰ | å¾ŒçºŒ |
||-----|------|------|
|| [9.3](ch9-3-æŠ€è¡“æ¶æ§‹.md) | **9.4** | [9.5](ch9-5-è³‡æ–™æ¨¡å‹è©³ç´°å®šç¾©.md) |

**å¿«é€Ÿéˆæ¥ï¼š**
- [â† è¿”å›ç¬¬9ç« é¦–é ](ch9-index.md)
