<!-- LEGACY FILE NOTICE -->
> âš ï¸ æ­¤æª”æ¡ˆç‚ºèˆŠç‰ˆå‚™ä»½ï¼Œå·²è¢«æ–°æª”å–ä»£ï¼š [ch6-8-å®‰å…¨è€ƒè™‘.md](ch6-8-å®‰å…¨è€ƒè™‘.md)\n> å‚™ä»½æ™‚é–“ï¼š2025-10-31 12:28:26\n
---

**[â† è¿”å›ç¬¬6ç« é¦–é ](ch6-index.md)**

---

### 6.8 å®‰å…¨è€ƒè™‘

#### 6.8.1 LLMè¾“å‡ºå®‰å…¨

1. **è¾“å‡ºè¿‡æ»¤å™¨**
   ```python
   class SafetyFilter:
       """å®‰å…¨è¿‡æ»¤å™¨ï¼Œé˜²æ­¢LLMè¾“å‡ºæœ‰å®³å†…å®¹"""
       
       def __init__(self, config: Config):
           self.config = config
           self.logger = logging.getLogger(__name__)
           self.blocked_keywords = self._load_blocked_keywords()
       
       def _load_blocked_keywords(self) -> List[str]:
           """åŠ è½½å±è”½å…³é”®è¯"""
           # ä»é…ç½®æˆ–æ•°æ®åº“åŠ è½½
           return [
               "rm -rf /",
               "sudo",
               "os.system",
               "subprocess.",
               "eval(",
               "exec(",
               "import os",
               "import sys",
               "import subprocess",
               "import ctypes",
               "shutil.rmtree",
               "format C:\\",
               "delete all",
               "malicious code"
           ]
       
       def filter(self, output: str) -> Tuple[bool, str, List[str]]:
           """
           è¿‡æ»¤LLMè¾“å‡º
           
           :param output: LLMç”Ÿæˆçš„è¾“å‡º
           :return: (æ˜¯å¦å®‰å…¨, å®‰å…¨è¾“å‡º, æ£€æµ‹åˆ°çš„é£é™©)
           """
           risks = []
           
           # 1. æ£€æŸ¥å…³é”®è¯
           for keyword in self.blocked_keywords:
               if keyword.lower() in output.lower():
                   risks.append(f"æ½œåœ¨å±é™©å…³é”®è¯: {keyword}")
           
           # 2. æ£€æŸ¥ä»£ç æ‰§è¡Œå‘½ä»¤
           if re.search(r'os\.(system|popen|exec)', output):
               risks.append("æ£€æµ‹åˆ°æ½œåœ¨å±é™©çš„ç³»ç»Ÿå‘½ä»¤è°ƒç”¨")
           
           # 3. æ£€æŸ¥æ–‡ä»¶åˆ é™¤æ“ä½œ
           if re.search(r'(shutil\.rmtree|os\.remove|os\.unlink)', output):
               risks.append("æ£€æµ‹åˆ°æ½œåœ¨å±é™©çš„æ–‡ä»¶åˆ é™¤æ“ä½œ")
           
           # 4. æ£€æŸ¥æ•æ„Ÿä¿¡æ¯
           if re.search(r'password|secret|token|api_key', output, re.IGNORECASE):
               risks.append("æ£€æµ‹åˆ°æ½œåœ¨çš„æ•æ„Ÿä¿¡æ¯æš´éœ²")
           
           # 5. å¦‚æœæœ‰é£é™©ï¼Œè¿”å›è¿‡æ»¤åçš„è¾“å‡º
           if risks:
               # ç§»é™¤æ½œåœ¨å±é™©å†…å®¹
               safe_output = self._sanitize_output(output)
               return False, safe_output, risks
           
           return True, output, []
       
       def _sanitize_output(self, output: str) -> str:
           """æ¸…ç†è¾“å‡ºä¸­çš„å±é™©å†…å®¹"""
           # æ›¿æ¢å±é™©å‘½ä»¤
           sanitized = re.sub(r'rm\s+-rf\s+/', 'SAFE_rm -rf /', output)
           sanitized = re.sub(r'os\.system\((.*?)\)', 'os.system(SAFE_COMMAND)', sanitized)
           
           # ç§»é™¤æ•æ„Ÿä¿¡æ¯
           sanitized = re.sub(r'password\s*=\s*["\'].*?["\']', 'password = "***"', sanitized)
           sanitized = re.sub(r'api_key\s*=\s*["\'].*?["\']', 'api_key = "***"', sanitized)
           
           return sanitized
   ```

2. **æ²™ç®±ä»£ç æ‰§è¡Œ**
   ```python
   class CodeSandbox:
       """ä»£ç æ²™ç®±ï¼Œå®‰å…¨æ‰§è¡Œä»£ç """
       
       def __init__(self, config: Config):
           self.config = config
           self.logger = logging.getLogger(__name__)
       
       def execute(self, code: str, timeout: int = 5) -> Dict:
           """
           åœ¨æ²™ç®±ä¸­æ‰§è¡Œä»£ç 
           
           :param code: è¦æ‰§è¡Œçš„ä»£ç 
           :param timeout: è¶…æ—¶æ—¶é—´(ç§’)
           :return: æ‰§è¡Œç»“æœ
           """
           # 1. åˆ›å»ºéš”ç¦»ç¯å¢ƒ
           sandbox_dir = self._create_sandbox()
           
           try:
               # 2. å†™å…¥ä»£ç åˆ°æ–‡ä»¶
               code_path = os.path.join(sandbox_dir, "code.py")
               with open(code_path, "w") as f:
                   f.write(code)
               
               # 3. é™åˆ¶èµ„æº
               resource_limits = {
                   "cpu_time": self.config.sandbox_cpu_time,
                   "memory": self.config.sandbox_memory,
                   "disk_space": self.config.sandbox_disk_space
               }
               
               # 4. æ‰§è¡Œä»£ç 
               result = self._run_with_limits(
                   ["python", code_path],
                   cwd=sandbox_dir,
                   timeout=timeout,
                   resource_limits=resource_limits
               )
               
               # 5. æ”¶é›†ç»“æœ
               return {
                   "stdout": result.stdout,
                   "stderr": result.stderr,
                   "returncode": result.returncode,
                   "duration": result.duration,
                   "error": result.error
               }
               
           finally:
               # 6. æ¸…ç†æ²™ç®±
               self._cleanup_sandbox(sandbox_dir)
       
       def _create_sandbox(self) -> str:
           """åˆ›å»ºæ²™ç®±ç¯å¢ƒ"""
           sandbox_dir = tempfile.mkdtemp(prefix="sandbox_")
           
           # åˆ›å»ºå¿…è¦çš„ç›®å½•ç»“æ„
           os.makedirs(os.path.join(sandbox_dir, "output"), exist_ok=True)
           
           # å¤åˆ¶å¿…è¦çš„åº“ï¼ˆå¦‚æœéœ€è¦ï¼‰
           # ...
           
           return sandbox_dir
       
       def _run_with_limits(
           self,
           command: List[str],
           cwd: str,
           timeout: int,
           resource_limits: Dict
       ) -> ExecutionResult:
           """åœ¨èµ„æºé™åˆ¶ä¸‹è¿è¡Œå‘½ä»¤"""
           start_time = time.time()
           
           try:
               # ä½¿ç”¨subprocessè¿è¡Œï¼Œå¸¦è¶…æ—¶
               process = subprocess.Popen(
                   command,
                   cwd=cwd,
                   stdout=subprocess.PIPE,
                   stderr=subprocess.PIPE,
                   text=True
               )
               
               try:
                   stdout, stderr = process.communicate(timeout=timeout)
                   duration = time.time() - start_time
                   
                   return ExecutionResult(
                       stdout=stdout,
                       stderr=stderr,
                       returncode=process.returncode,
                       duration=duration,
                       error=None
                   )
               except subprocess.TimeoutExpired:
                   process.kill()
                   return ExecutionResult(
                       stdout="",
                       stderr="Execution timed out",
                       returncode=-1,
                       duration=timeout,
                       error="Timeout"
                   )
                   
           except Exception as e:
               return ExecutionResult(
                   stdout="",
                   stderr=str(e),
                   returncode=-1,
                   duration=time.time() - start_time,
                   error=str(e)
               )
       
       def _cleanup_sandbox(self, sandbox_dir: str):
           """æ¸…ç†æ²™ç®±ç¯å¢ƒ"""
           try:
               shutil.rmtree(sandbox_dir)
           except Exception as e:
               self.logger.error("Error cleaning up sandbox: %s", str(e))
   ```

#### 6.8.2 æ•°æ®éšç§ä¿æŠ¤

1. **æ•°æ®è„±æ•ä¸­é—´ä»¶**
   ```python
   class DataAnonymizer:
       """æ•°æ®è„±æ•ä¸­é—´ä»¶"""
       
       def __init__(self, config: Config):
           self.config = config
           self.logger = logging.getLogger(__name__)
           self.patterns = self._load_patterns()
       
       def _load_patterns(self) -> List[Dict]:
           """åŠ è½½è„±æ•æ¨¡å¼"""
           return [
               {
                   "name": "email",
                   "pattern": r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
                   "replacement": "userXXXX@example.com",
                   "enabled": True
               },
               {
                   "name": "phone",
                   "pattern": r'\b(?:\+?(\d{1,3}))?[-. (]*(\d{3})[-. )]*(\d{3})[-. ]*(\d{4})\b',
                   "replacement": "(XXX) XXX-XXXX",
                   "enabled": True
               },
               {
                   "name": "credit_card",
                   "pattern": r'\b(?:\d[ -]*?){13,16}\b',
                   "replacement": "XXXX-XXXX-XXXX-XXXX",
                   "enabled": True
               }
           ]
       
       def anonymize(self, data: Any) -> Any:
           """
           è„±æ•æ•°æ®
           
           :param data: è¦è„±æ•çš„æ•°æ®
           :return: è„±æ•åçš„æ•°æ®
           """
           if isinstance(data, str):
               return self._anonymize_string(data)
           
           elif isinstance(data, dict):
               return {k: self.anonymize(v) for k, v in data.items()}
           
           elif isinstance(data, list):
               return [self.anonymize(item) for item in data]
           
           return data
       
       def _anonymize_string(self, text: str) -> str:
           """è„±æ•å­—ç¬¦ä¸²"""
           result = text
           
           for pattern in self.patterns:
               if pattern["enabled"]:
                   result = re.sub(
                       pattern["pattern"], 
                       pattern["replacement"], 
                       result
                   )
           
           return result
   ```

---

## ğŸ“‘ ç›¸å…³ç« èŠ‚

| å‰åº | å½“å‰ | åç»­ |
|-----|------|------|
| [6.7](ch6-7.md) | **6.8** | [6.9](ch6-9.md) |

**å¿«é€Ÿé“¾æ¥ï¼š**
- [â† è¿”å›ç¬¬6ç« é¦–é ](ch6-index.md)
